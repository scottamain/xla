{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XLA","text":"<p>XLA is an open source, state-of-art compiler for machine learning that takes models from popular frameworks such as PyTorch, TensorFlow, and JAX, and optimizes them for high-performance execution across different hardware platforms including GPUs, CPUs, and ML accelerators. For example, in BERT MLPerf submission, using XLA with 8 Volta V100 GPUs achieved a ~7x performance improvement and ~5x batch size improvement (vs the same GPUs without XLA).</p> <p>As a part of the OpenXLA project, XLA is built collaboratively by industry-leading ML hardware and software companies, including Alibaba, Amazon Web Services, AMD, Apple, Arm, Google, Intel, Meta, and NVIDIA.</p>"},{"location":"#key-benefits","title":"Key benefits","text":"<ul> <li> <p> Build anywhere: XLA is already integrated into leading ML frameworks such as TensorFlow, PyTorch, and JAX.</p> </li> <li> <p> Run anywhere: It supports various backends including GPUs, CPUs, and ML accelerators, and includes a pluggable infrastructure to add support for more.</p> </li> <li> <p> Maximize and scale performance: It optimizes a model's performance with production-tested optimization passes and automated partitioning for model parallelism.</p> </li> <li> <p> Eliminate complexity: It leverages the power of MLIR to bring the best capabilities into a single compiler toolchain, so you don't have to manage a range of domain-specific compilers.</p> </li> <li> <p> Future ready: As an open source project, built through a collaboration of leading ML hardware and software vendors, XLA is designed to operate at the cutting-edge of the ML industry.</p> </li> </ul>"},{"location":"aliasing/","title":"Aliasing in XLA","text":"<p>This document describes the aliasing API for XLA: when building an XLA program, you can specify the desired aliasing between the input and output buffers.</p>"},{"location":"aliasing/#defining-aliasing-at-compile-time","title":"Defining aliasing at compile-time","text":"<p>For example, consider a trivial HLO module which simply adds <code>1</code> to its input:</p> <pre><code>HloModule increment\n\nENTRY entry {\n  %p = f32[] parameter(0)\n  %c = f32[] constant(1)\n  ROOT %out = f32[] add(%p, %c)\n}\n</code></pre> <p>This module will allocate two 4-byte buffers: one for the input <code>%p</code>, and one for the output <code>%out</code>.</p> <p>However, it is often desirable to perform the update in-place (for example, if in the frontend generating the expression the input variable is no longer alive after the computation, as in the increment <code>p++</code>).</p> <p>To perform such an update efficiently, you can specify the input aliasing:</p> <pre><code>HloModule increment, input_output_alias={ {}: 0 }\n\nENTRY entry {\n  %p = f32[] parameter(0)\n  %c = f32[] constant(1)\n  ROOT %out = f32[] add(%p, %c)\n}\n</code></pre> <p>The format specifies that the entire output (marked by <code>{}</code>) is aliased to the input parameter <code>0</code>.</p> <p>See the <code>XlaBuilder::SetUpAlias</code> API to specify the aliasing programmatically.</p>"},{"location":"aliasing/#defining-aliasing-at-run-time","title":"Defining aliasing at run-time","text":"<p>The aliasing defined in the previous step is specified during the compilation. During the execution, you can choose whether to donate the buffer using the <code>LocalClient::RunAsync</code> API.</p> <p>Input buffers to the program are wrapped in <code>ExecutionInput</code>, which in turn contain a tree of <code>MaybeOwningDeviceMemory</code>. If memory is specified as owning (ownership of the buffer is passed to the XLA runtime), the buffer is actually donated, and the update is executed in-place, as requested by the compile-time aliasing API.</p> <p>If, however, the buffer which is aliased at compile time is not donated at runtime, copy-protection kicks in: an extra output buffer <code>O</code> is allocated, and the contents of the input buffer <code>P</code> which was meant to be aliased are copied into <code>O</code> (so effectively the program can execute as if the buffer <code>O</code> was donated at runtime).</p>"},{"location":"architecture/","title":"XLA Architecture","text":"<p>XLA is a machine learning (ML) compiler that optimizes linear algebra (XLA = accelerated linear algebra), providing improvements in execution speed and memory usage. This page provides a brief overview of the the XLA compiler's objectives and architecture.</p>"},{"location":"architecture/#objectives","title":"Objectives","text":"<p>Today, XLA supports several ML framework frontends (such as PyTorch, TensorFlow, and JAX) and is part of the OpenXLA project\u2014an ecosystem of open-source compiler technologies for ML that's developed collaboratively by leading ML hardware and software organizations. Before the OpenXLA project was created, XLA was developed inside the TensorFlow project, but the fundamental objectives have remained the same:</p> <ul> <li> <p>Improve execution speed. Compile subgraphs to reduce the execution time     of short-lived ops to eliminate overhead from the execution runtime, fuse     pipelined operations to reduce memory overhead, and specialize known     tensor shapes to allow for more aggressive constant propagation.</p> </li> <li> <p>Improve memory usage. Analyze and schedule memory usage,     eliminating many intermediate storage buffers.</p> </li> <li> <p>Reduce reliance on custom ops. Remove the need for many custom ops by     improving the performance of automatically fused low-level ops to match the     performance of custom ops that were originally fused by hand.</p> </li> <li> <p>Improve portability. Make it relatively easy to write a new backend for     novel hardware, at which point a large fraction of ML models can     run unmodified on that hardware. This is in contrast with the approach of     specializing individual monolithic ops for new hardware, which requires     models be rewritten to make use of those ops.</p> </li> </ul>"},{"location":"architecture/#how-it-works","title":"How it works","text":"<p>The XLA Compiler takes model graphs from ML frameworks defined in StableHLO and compiles them into machine instructions for various architectures. StableHLO defines a versioned operation set (HLO = high level operations) that provides a portability layer between ML frameworks and the compiler.</p> <p>In general, the compilation process that converts the model graph into a target-optimized executable includes these steps:</p> <ol> <li> <p>XLA performs several built-in optimization and analysis passes on the StableHLO graph that are target-independent, such as CSE, target-independent operation fusion, and buffer analysis for allocating runtime memory for the computation. During this optimization stage, XLA also converts the StableHLO dialect into an internal HLO dialect.</p> </li> <li> <p>XLA sends the HLO computation to a backend for further HLO-level optimizations, this time with target-specific information and needs in mind. For example, the GPU backend may perform operation fusions that are beneficial specifically for the GPU programming model and determine how to partition the computation into streams. At this stage, backends may also pattern-match certain operations or combinations thereof to optimized library calls.</p> </li> <li> <p>The backend then performs target-specific code generation. The CPU and GPU backends included with XLA use LLVM for low-level IR, optimization, and code-generation. These backends emit the LLVM IR necessary to represent the HLO computation in an efficient manner, and then invoke LLVM to emit native code from this LLVM IR.</p> </li> </ol> <p>Within this process, the XLA Compiler is modular in the sense that it is easy to slot-in an alternative backend to target some novel HW architecture. The GPU backend currently supports NVIDIA GPUs via the LLVM NVPTX backend; the CPU backend supports multiple CPU ISAs.</p>"},{"location":"broadcasting/","title":"Broadcasting semantics","text":"<p>This document describes how the broadcasting semantics in XLA work.</p>"},{"location":"broadcasting/#what-is-broadcasting","title":"What is broadcasting?","text":"<p>Broadcasting is the process of making arrays with different shapes have compatible shapes for arithmetic operations. The terminology is borrowed from Numpy broadcasting.</p> <p>Broadcasting may be required for operations between multi-dimensional arrays of different ranks, or between multi-dimensional arrays with different but compatible shapes. Consider the addition <code>X+v</code> where <code>X</code> is a matrix (an array of rank 2) and <code>v</code> is a vector (an array of rank 1). To perform element-wise addition, XLA needs to \"broadcast\" the vector <code>v</code> to the same rank as the matrix <code>X</code>, by replicating <code>v</code> a certain number of times. The vector's length has to match at least one of the dimensions of the matrix.</p> <p>For example:</p> <pre><code>|1 2 3| + |7 8 9|\n|4 5 6|\n</code></pre> <p>The matrix's dimensions are (2,3), the vector's are (3). The vector is broadcast by replicating it over rows to get:</p> <pre><code>|1 2 3| + |7 8 9| = |8  10 12|\n|4 5 6|   |7 8 9|   |11 13 15|\n</code></pre> <p>In Numpy, this is called broadcasting.</p>"},{"location":"broadcasting/#principles","title":"Principles","text":"<p>The XLA language is as strict and explicit as possible, avoiding implicit and \"magical\" features. Such features may make some computations slightly easier to define, at the cost of more assumptions baked into user code that will be difficult to change in the long term. If necessary, implicit and magical features can be added in client-level wrappers.</p> <p>In regards to broadcasting, explicit broadcasting specifications on operations between arrays of different ranks is required. This is different from Numpy, which infers the specification when possible.</p>"},{"location":"broadcasting/#broadcasting-a-lower-rank-array-onto-a-higher-rank-array","title":"Broadcasting a lower-rank array onto a higher-rank array","text":"<p>Scalars can always be broadcast over arrays without an explicit specification of broadcasting dimensions. An element-wise binary operation between a scalar and an array means applying the operation with the scalar for each element in the array. For example, adding a scalar to a matrix means producing a matrix each element of which is a sum of the scalar with the corresponding input matrix's element.</p> <pre><code>|1 2 3| + 7 = |8  9  10|\n|4 5 6|       |11 12 13|\n</code></pre> <p>Most broadcasting needs can be captured by using a tuple of dimensions on a binary operation. When the inputs to the operation have different ranks, this broadcasting tuple specifies which dimension(s) in the higher-rank array to match with the lower-rank array.</p> <p>Consider the previous example, instead of adding a scalar to a (2,3) matrix, add a vector of dimension (3) to a matrix of dimensions (2,3). Without specifying broadcasting, this operation is invalid. To correctly request matrix-vector addition, specify the broadcasting dimension to be (1), meaning the vector's dimension is matched to dimension 1 of the matrix. In 2D, if dimension 0 is considered as rows and dimension 1 as columns, this means that each element of the vector becomes a column of a size matching the number of rows in the matrix:</p> <pre><code>|7 8 9| ==&gt; |7 8 9|\n            |7 8 9|\n</code></pre> <p>As a more complex example, consider adding a 3-element vector (dimension (3)) to a 3x3 matrix (dimensions (3,3)). There are two ways broadcasting can happen for this example:</p> <p>(1) A broadcasting dimension of 1 can be used. Each vector element becomes a column and the vector is duplicated for each row in the matrix.</p> <pre><code>|7 8 9| ==&gt; |7 8 9|\n            |7 8 9|\n            |7 8 9|\n</code></pre> <p>(2) A broadcasting dimension of 0 can be used. Each vector element becomes a row and the vector is duplicated for each column in the matrix.</p> <pre><code> |7| ==&gt; |7 7 7|\n |8|     |8 8 8|\n |9|     |9 9 9|\n</code></pre>  <p>Note</p> <p>When adding a 2x3 matrix to a 3-element vector, a broadcasting dimension of 0 is invalid.</p>  <p>The broadcasting dimensions can be a tuple that describes how a smaller rank shape is broadcast into a larger rank shape. For example, given a 2x3x4 cuboid and a 3x4 matrix, a broadcasting tuple (1,2) means matching the matrix to dimensions 1 and 2 of the cuboid.</p> <p>This type of broadcast is used in the binary ops in <code>XlaBuilder</code>, if the <code>broadcast_dimensions</code> argument is given. For example, see XlaBuilder::Add. In the XLA source code, this type of broadcasting is sometimes called \"InDim\" broadcasting.</p>"},{"location":"broadcasting/#formal-definition","title":"Formal definition","text":"<p>The broadcasting attribute allows matching a lower-rank array to a higher-rank array, by specifying which dimensions of the higher-rank array to match. For example, for an array with dimensions MxNxPxQ, a vector with dimension T can be matched as follows:</p> <pre><code>          MxNxPxQ\n\ndim 3:          T\ndim 2:        T\ndim 1:      T\ndim 0:    T\n</code></pre> <p>In each case, T has to be equal to the matching dimension of the higher-rank array. The vector's values are then broadcast from the matched dimension to all the other dimensions.</p> <p>To match a TxV matrix onto the MxNxPxQ array, a pair of broadcasting dimensions are used:</p> <pre><code>          MxNxPxQ\ndim 2,3:      T V\ndim 1,2:    T V\ndim 0,3:  T     V\netc...\n</code></pre> <p>The order of dimensions in the broadcasting tuple has to be the order in which the lower-rank array's dimensions are expected to match the higher-rank array's dimensions. The first element in the tuple says which dimension in the higher-rank array has to match dimension 0 in the lower-rank array. The second element for dimension 1, and so on. The order of broadcast dimensions has to be strictly increasing. For example, in the previous example it is illegal to match V to N and T to P; it is also illegal to match V to both P and N.</p>"},{"location":"broadcasting/#broadcasting-similar-rank-arrays-with-degenerate-dimensions","title":"Broadcasting similar-rank arrays with degenerate dimensions","text":"<p>A related broadcasting problem is broadcasting two arrays that have the same rank but different dimension sizes. Similarly to Numpy's rules, this is only possible when the arrays are compatible. Two arrays are compatible when all their dimensions are compatible. Two dimensions are compatible if:</p> <ul> <li>They are equal, or</li> <li>One of them is 1 (a \"degenerate\" dimension)</li> </ul> <p>When two compatible arrays are encountered, the result shape has the maximum among the two inputs at every dimension index.</p> <p>Examples:</p> <ol> <li>(2,1) and (2,3) broadcast to (2,3).</li> <li>(1,2,5) and (7,2,5) broadcast to (7,2,5)</li> <li>(7,2,5) and (7,1,5) broadcast to (7,2,5)</li> <li>(7,2,5) and (7,2,6) are incompatible and cannot be broadcast.</li> </ol> <p>A special case arises, and is also supported, where each of the input arrays has a degenerate dimension at a different index. In this case, the result is an \"outer operation\": (2,1) and (1,3) broadcast to (2,3). For more examples, consult the Numpy documentation on broadcasting.</p>"},{"location":"broadcasting/#broadcast-composition","title":"Broadcast composition","text":"<p>Broadcasting of a lower-rank array to a higher-rank array and broadcasting using degenerate dimensions can both be performed in the same binary operation. For example, a vector of size 4 and a matrix of size 1x2 can be added together using broadcast dimensions value of (0):</p> <pre><code>|1 2 3 4| + [5 6]    // [5 6] is a 1x2 matrix, not a vector.\n</code></pre> <p>First the vector is broadcast up to rank 2 (matrix) using the broadcast dimensions. The single value (0) in the broadcast dimensions indicates that dimension zero of the vector matches to dimension zero of the matrix. This produces a matrix of size 4xM where the value M is chosen to match the corresponding dimension size in the 1x2 array. Therefore, a 4x2 matrix is produced:</p> <pre><code>|1 1| + [5 6]\n|2 2|\n|3 3|\n|4 4|\n</code></pre> <p>Then \"degenerate dimension broadcasting\" broadcasts dimension zero of the 1x2 matrix to match the corresponding dimension size of the right hand side:</p> <pre><code>|1 1| + |5 6|     |6  7|\n|2 2| + |5 6|  =  |7  8|\n|3 3| + |5 6|     |8  9|\n|4 4| + |5 6|     |9 10|\n</code></pre> <p>A more complicated example is a matrix of size 1x2 added to an array of size 4x3x1 using broadcast dimensions of (1, 2). First the 1x2 matrix is broadcast up to rank 3 using the broadcast dimensions to produces an intermediate Mx1x2 array where the dimension size M is determined by the size of the larger operand (the 4x3x1 array) producing a 4x1x2 intermediate array. The M is at dimension 0 (left-most dimension) because the dimensions 1 and 2 are mapped to the dimensions of the original 1x2 matrix as the broadcast dimension are (1, 2). This intermediate array can be added to the 4x3x1 matrix using broadcasting of degenerate dimensions to produce a 4x3x2 array result.</p>"},{"location":"code_reviews_guide/","title":"Code Reviews Guide","text":"<p>The purpose of this document is to explain the reasoning behind XLA team's position on code reviews -- a position that has grown from years of collective experience working on open source projects in general and XLA in particular.</p> <p>Different open-source projects have different cultural expectations for how much reviewers can ask of code authors. In some projects, reviewers will take a \"mostly correct\" pull request (PR), modify it themselves, and submit it. XLA takes the opposite approach: We expect authors to iterate on PRs until they're good enough to submit without additional changes.</p> <p>The main reason for this approach is that we want PR authors to learn to be fully-fledged XLA contributors. If reviewers fix issues in the PR themselves, then it's much harder for authors to learn. The XLA approach can be challenging for both reviewers and reviewees, but we believe it ultimately helps us grow the community.</p> <p>Learning to be a \"fully-fledged XLA contributor\" isn't just about writing code that doesn't have bugs. There's much more to learn about \"how to modify XLA.\" This includes:</p> <ul> <li>coding style,</li> <li>which edge cases to look out for,</li> <li>expectations around writing tests,</li> <li>expectations around comments and PR descriptions,</li> <li>and expectations around building infrastructure to support your change.</li> </ul> <p>As you build knowledge of the project and trust from reviewers, you can expect that you'll get fewer comments, because you're naturally writing code more aligned with your reviewer's expectations.</p> <p>Like many open-source projects, XLA has a few highly-experienced people and many relatively new people. Those of us who are highly experienced have many demands on our time. To keep PRs moving forward in a timely manner you can help reduce the time reviewers need and the number of iterations required by:</p> <ul> <li>Carefully reviewing and/or having your PR reviewed by a colleague before     sending it: Try to remove as many trivial mistakes (code style, spelling     and grammar mistakes, etc.) before sending the PR for review. Make sure all     tests pass.</li> <li>Carefully reading your reviewer's comments: Try to understand what the     reviewer is asking for and attempt to address all comments before you push a     new version.</li> <li>Avoiding tangential discussions (bikeshedding): Technical discussions and     disagreements are highly valuable and nobody is perfect. However, avoid     discussions that don't make a difference or are merely stylistic. If you     disagree with a reviewer's comment, try to detail your reasons as precisely     and comprehensively as possible to avoid long back-and-forth discussions.</li> <li>Avoiding asking the \"commonly asked review questions\" listed below: We     have listed some answers to common questions and our rationale below.</li> </ul> <p>In general, we invite you to try to make reviewing your PRs take as little time for us as possible. Then we will want to review your changes quickly!</p> <p>Thank you for contributing to XLA and happy hacking!</p>"},{"location":"code_reviews_guide/#commonly-asked-review-questions","title":"Commonly asked review questions","text":""},{"location":"code_reviews_guide/#this-infrastructure-change-is-not-related-to-my-pr-why-should-i-do-it","title":"\"This infrastructure change is not related to my PR, why should I do it?\"","text":"<p>The XLA team doesn't have a dedicated infrastructure team, so it's up to us all to build helper libraries and avoid technical debt. We consider it to be a regular part of making changes to XLA, and everyone is expected to participate. We generally build infrastructure as-needed when writing code.</p> <p>XLA reviewers may ask you to build some infrastructure (or otherwise make a large change to a PR) along with a PR that you've written. This request may seem unnecessary or orthogonal to the change you're trying to make. This is likely because of a mismatch between your expectations about how much infra you need to build and your reviewer's expectations for the same.</p> <p>A mismatch in expectations is okay! That's expected when you're new to a project (and it sometimes even happens to us old hats). It's likely that projects you've worked on in the past have different expectations. That's also okay and expected! It doesn't mean either one of these projects has the wrong approach; they're just different. We invite you to take infra requests alongside all other review comments as an opportunity to learn what we expect on this project.</p>"},{"location":"code_reviews_guide/#can-i-address-your-comment-in-a-future-pr","title":"\"Can I address your comment in a future PR?\"","text":"<p>A frequent question with respect to infrastructure requests (or other large requests) in PRs is whether or not the change must be made in the original PR, or whether it can be done as a follow-up in a future PR.</p> <p>In general, XLA does not allow PR authors to address review comments as a follow-up PR. When a reviewer decides that something needs to be addressed in this PR, we generally expect authors to address it in the original PR, even if what's requested is a large change. This standard applies externally and also internally within Google.</p> <p>There are a few reasons that XLA takes this approach.</p> <ul> <li> <p>Trust: Having earned the reviewer's trust is a key component. In an     open-source project, contributors can appear or disappear at will. After we     approve a PR, reviewers have no way to ensure that any promised follow-ups     actually get done.</p> </li> <li> <p>Impact on other developers: If you have sent a PR touching a particular     part of XLA, there's a good chance other people are looking at the same     part. If we accept technical debt in your PR, then everyone who's looking at     this file will be impacted by this debt until the follow-up is submitted.</p> </li> <li> <p>Reviewer bandwidth: Deferring a change to a follow-up imposes multiple     costs on our already-overloaded reviewers. Reviewers will probably forget     what this PR was about while waiting for the follow-up, making the next     review more difficult. Also, reviewers will have to keep track of the     follow-ups they're waiting on, making sure that they actually happen. If the     change can be made such that it is truly orthogonal to the original PR so     that some other reviewer could review it, bandwidth would be less of a     problem. In our experience, this is rarely the case.</p> </li> </ul>"},{"location":"custom_call/","title":"XLA custom calls","text":"<p>This document describes how to write and use XLA \"custom calls\". Custom calls let you invoke code written in a programming language like C++ or CUDA from an XLA program.</p>  <p>Warning</p> <p>Custom calls are a low-level power-user feature. It is easy to break your program in difficult-to-debug (and even difficult-to-notice) ways using custom-calls. You shouldn't use custom calls unless you're prepared to debug XLA yourself when something goes wrong, and you should expect relatively less assistance from XLA developers if you run into trouble.</p>   <p>Warning</p> <p>The custom-call API/ABI is not currently stable. We don't intend to change it capriciously, but it may change. Some possible future changes are described below.</p>"},{"location":"custom_call/#custom-call-on-cpu","title":"Custom-call on CPU","text":"<p>You can create an HLO instruction which represents a custom-call via XLA's client API. For example, the following code uses a custom-call to compute <code>A[i] = B[i % 128]+ C[i]</code> on the CPU. (Of course you could -- and should! -- do this with regular HLO.)</p> <pre><code>#include \"xla/client/xla_builder.h\"\n#include \"xla/service/custom_call_target_registry.h\"\n\nvoid do_it() {\n  xla::XlaBuilder b(\"do_it\");\n  xla::XlaOp param0 =\n      xla::Parameter(&amp;b, 0, xla::ShapeUtil::MakeShape(xla::F32, {128}), \"p0\");\n  xla::XlaOp param1 =\n      xla::Parameter(&amp;b, 1, xla::ShapeUtil::MakeShape(xla::F32, {2048}), \"p1\");\n  xla::XlaOp custom_call =\n      xla::CustomCall(&amp;b, \"do_custom_call\", /*operands=*/{param0, param1},\n                      /*shape=*/xla::ShapeUtil::MakeShape(xla::F32, {2048}));\n}\n\nvoid do_custom_call(void* out, const void** in) {\n  float* out_buf = reinterpret_cast&lt;float*&gt;(out);\n  const float* in0 = reinterpret_cast&lt;const float*&gt;(in[0]);\n  const float* in1 = reinterpret_cast&lt;const float*&gt;(in[1]);\n  for (int i = 0; i &lt; 2048; ++i) {\n    out_buf[i] = in0[i % 128] + in1[i];\n  }\n}\nXLA_REGISTER_CUSTOM_CALL_TARGET(do_custom_call, \"Host\");\n</code></pre> <p>Notice that the function <code>do_custom_call</code> needs to know the dimensions of the buffers it operates over. In this example we hardcode the sizes 128 and 2048. If you don't want to do this, you can pass the dimensions in as parameters to the call.</p>"},{"location":"custom_call/#custom-call-on-gpu","title":"Custom-call on GPU","text":"<p>The GPU custom call framework is somewhat different than that on the CPU. Here is a CUDA example that does the same <code>A[i] = B[i % 128] + C[i]</code> computation as the CPU code above.</p> <pre><code>void do_it() { /* same implementation as above */ }\n\n__global__ custom_call_kernel(const float* in0, const float* in1, float* out) {\n  size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n  out[idx] = in0[idx % 128] + in1[idx];\n}\n\nvoid do_custom_call(CUstream stream, void** buffers,\n                    const char* opaque, size_t opaque_len) {\n  const float* in0 = reinterpret_cast&lt;const float*&gt;(buffers[0]);\n  const float* in1 = reinterpret_cast&lt;const float*&gt;(buffers[1]);\n  float* out = reinterpret_cast&lt;float*&gt;(buffers[2]);\n\n  const int64_t block_dim = 64;\n  const int64_t grid_dim = 2048 / block_dim;\n  custom_call_kernel&lt;&lt;&lt;grid_dim, block_dim,\n                       /*dynamic_shared_mem_bytes=*/0, stream&gt;&gt;&gt;(in0, in1, out);\n}\nXLA_REGISTER_CUSTOM_CALL_TARGET(do_custom_call, \"CUDA\");\n</code></pre> <p>Notice first that the GPU custom call function is still a function executed on the CPU. Our <code>do_custom_call</code> CPU function is responsible for enqueueing work on the GPU. Here it launches a CUDA kernel, but it could also do something else, like call cublas.</p> <p><code>buffers</code> is an array of pointers which lives on the host, and each element it contains points to device (i.e. GPU) memory. The parameters come first, followed by the output value. This is notably different from the CPU calling convention, which has two params, <code>ins</code> and <code>out</code>. The main reason we diverge is to make it possible to handle tuple-shaped inputs/outputs efficiently; see the section below.</p> <p>As in the CPU example, we've hardcoded the input and output buffer sizes into our custom call. However unlike in the CPU case, passing the buffer sizes in as operands to the custom call would not work well. Usually we need the buffer sizes available to us on the CPU; e.g. when launching a kernel, we need to know the block/grid dimensions to use. But if we were to pass the buffer sizes as operands to our custom call, their values would live in GPU memory. We'd then have to do an expensive synchronous device-to-host memcpy at the start of our operation just to read the sizes.</p> <p>To let you work around this, we provide the <code>opaque</code> parameter. You can set this to an arbitrary string of bytes when you create the custom call:</p> <pre><code>std::string opaque = \"...\";\nxla::CustomCall(&amp;b, \"do_custom_call\", /*operands=*/{param0, param1},\n                /*output_shape=*/xla::ShapeUtil::MakeShape(xla::F32, {2048}),\n                opaque);\n</code></pre> <p>Since <code>xla::Shape</code> has a protocol buffer representation, you could store this serialized proto inside of <code>opaque</code> and deserialize it within your GPU custom-call. Note however that although <code>xla::ShapeProto</code> does not change frequently, it does change. Check the git log to see how it has changed in the past.</p>"},{"location":"custom_call/#signalling-an-error","title":"Signalling an error","text":"<p>If your custom call encounters an error, you can signal the error to the XLA runtime (instead of e.g. crashing or returning nonsense in the output buffers) by using the following signature for your function on CPU:</p> <pre><code>#include \"xla/service/custom_call_status.h\"\n\nvoid do_custom_call(void* out, const void** in, XlaCustomCallStatus* status);\n</code></pre> <p>... and on GPU:</p> <pre><code>#include \"xla/service/custom_call_status.h\"\n\nvoid do_custom_call(CUstream stream, void** buffers, const char* opaque,\n                    size_t opaque_len, xla::XlaCustomCallStatus* status);\n</code></pre> <p>You can signal failure by using <code>XlaCustomCallStatusSetFailure</code>, e.g.:</p> <pre><code>void do_custom_call(void* out, const void** in, XlaCustomCallStatus* status) {\n  // ... do some work.\n\n  if (bad_condition) {\n    char* error_message = \"An error occurred\";\n    XlaCustomCallStatusSetFailure(status, error_message, strlen(error_message));\n    return;\n  }\n\n  // ... continue.\n}\n</code></pre> <p>You can also use <code>XlaCustomCallStatusSetSuccess</code> to indicate success, but the <code>XlaCustomCallStatus</code> is in a success state by default, so ignoring it completely will also indicate success.</p> <p>When using custom call functions with this signature, you must create the corresponding <code>custom-call</code> op with the appropriate API version set, e.g.:</p> <pre><code>xla::CustomCall(&amp;b, \"do_custom_call\", /*operands=*/{param0, param1},\n                /*output_shape=*/xla::ShapeUtil::MakeShape(F32, {2048}),\n                opaque, /*has_side_effect=*/false,\n                /*output_operand_aliasing=*/{}, /*literal=*/nullptr,\n                /*schedule=*/xla::CustomCallSchedule::SCHEDULE_NONE,\n                /*api_version=*/API_VERSION_STATUS_RETURNING);\n</code></pre>  <p>Note</p> <p>In the future all clients will be required to migrate their custom call functions to the new API version and the old one will be deprecated. For custom calls that can't fail, you can simply add the new <code>XlaCustomCallStatus*</code> parameter and then ignore it.</p>  <p>On failure, none of the custom call outputs will be used; the XLA runtime will terminate the computation. It is not possible for an HLO computation to recover from the error (e.g. by catching and handling it).</p>"},{"location":"custom_call/#passing-tuples-to-custom-calls","title":"Passing tuples to custom-calls","text":"<p>Consider the following custom-call.</p> <pre><code>using xla::ShapeUtil;\nusing xla::F32;\nShape p0_shape = ShapeUtil::MakeTuple({\n    ShapeUtil::MakeShape(F32, {32}),\n    ShapeUtil::MakeTuple({\n        ShapeUtil::MakeShape(F32, {64}),\n        ShapeUtil::MakeShape(F32, {128}),\n    }),\n    ShapeUtil::MakeShape(F32, {256}),\n});\nxla::XlaOp p0 = xla::Parameter(0, p0_shape, \"p0\");\n\nShape out_shape = ShapeUtil::MakeTuple({\n  ShapeUtil::MakeShape(F32, {512}),\n  ShapeUtil::MakeShape(F32, {1024}),\n});\nxla::CustomCall(&amp;b, \"do_custom_call\", /*operands=*/{p0}, out_shape);\n</code></pre> <p>On both CPU and GPU, a tuple is represented in memory as an array of pointers. In C++-pseudocode, parameter 0 above is laid out as follows.</p> <pre><code>// In-memory layout of parameter 0 from custom-call above.  True on both CPU\n// and GPU.\nfloat* subbuf0 = new float[32];\nfloat* subbuf1 = new float[64];\nfloat* subbuf2 = new float[128]\nfloat* subbuf3 = new float[256];\n\nvoid* subtuple = new void*[2];\n(*subtuple)[0] = subbuf1;\n(*subtuple)[1] = subbuf2;\n\nvoid* p0 = new void*[3];\n(*p0)[0] = subbuf0;\n(*p0)[1] = subtuple;\n(*p0)[2] = subbuf3;\n</code></pre> <p>Although the in-memory representation of tuples is the same in CPU and GPU, they are handled differently in the CPU and GPU custom-call calling conventions.</p>"},{"location":"custom_call/#tuple-outputs-as-temp-buffers","title":"Tuple outputs as temp buffers","text":"<p>Tuple inputs to custom-calls are a convenience, but they aren't strictly necessary. If we didn't support tuple inputs to custom calls, you could always unpack the tuples using get-tuple-element before passing them to the custom call.</p> <p>On the other hand, tuple outputs do let you do things you couldn't otherwise.</p> <p>The obvious reason to have tuple outputs is, that's how a custom call (or any other XLA op) returns multiple independent arrays.</p> <p>But less obviously, a tuple output is also a way to give your custom call temp memory. Yes, an output can represent a temp buffer. Consider, an output buffer has the property that the op can write to it, and it can read from it after it's been written to. That's exactly what you want from a temp buffer.</p> <p>In the example above, suppose we wanted to use the <code>F32[1024]</code> as a temp buffer. Then we'd write the HLO just as above, and we'd simply never read tuple index 1 of the custom call's output.</p>"},{"location":"custom_call/#tuples-in-cpu-custom-calls","title":"Tuples in CPU custom-calls","text":"<p>In CPU code, we have a function <code>do_custom_call(const void** ins, void* out)</code>. <code>ins</code> is an array with just one element, which points to <code>param0</code>. The subbuffers of <code>param0</code> are accessible by dereferencing that pointer, and the subbuffers of <code>output_tuple</code> are accessible by dereferencing <code>out</code>.</p>"},{"location":"custom_call/#tuples-in-gpu-custom-calls","title":"Tuples in GPU custom-calls","text":"<p>In GPU code, we have a function <code>do_custom_call(..., void** buffers, ...)</code>. In this case <code>buffers</code> is a host array of six device pointers, one for each leaf buffer in the input/output. To generate the flat list, we iterate over the parameters and output, and for each we do a preorder traversal of its shape. Concretely:</p> <pre><code>// Layout of `buffers` parameter to GPU custom call function for custom-call\n// above.\nbuffers[0] == subbuf0\nbuffers[1] == subbuf1\nbuffers[2] == subbuf2\nbuffers[3] == subbuf3\nbuffers[4] == output_subbuf0\nbuffers[5] == output_subbuf1\n</code></pre>"},{"location":"developing_new_backend/","title":"Developing a new backend for XLA","text":"<p>This guide is for system engineers who want XLA to output programs that target their hardware in an efficient manner. The guide is not step-by-step and assumes knowledge of LLVM, Bazel, and XLA.</p> <p>XLA provides an abstract interface that a new architecture or accelerator can implement to create a backend to run ML programs output by XLA. Retargeting XLA should be significantly simpler and scalable than implementing every existing op from a frontend framework such as PyTorch or TensorFlow for new hardware.</p> <p>Most implementations will fall into one of the following scenarios:</p> <ol> <li>Existing CPU architecture not yet officially supported by XLA, with or     without an existing LLVM backend.</li> <li>Non-CPU-like hardware with an existing LLVM backend.</li> <li>Non-CPU-like hardware without an existing LLVM backend.</li> </ol>  <p>Note</p> <p>An LLVM backend can mean either one of the officially released LLVM backends or a custom LLVM backend developed in-house.</p>"},{"location":"developing_new_backend/#scenario-1-existing-cpu-architecture-not-yet-officially-supported-by-xla","title":"Scenario 1: Existing CPU architecture not yet officially supported by XLA","text":"<p>In this scenario, start by looking at the existing XLA CPU backend. XLA makes it easy to target different CPUs by using LLVM, since the main difference between XLA backends for CPUs is the code generated by LLVM.</p> <p>If the hardware vendor has an LLVM backend for their hardware, it is simple to link the backend with the LLVM built with XLA. In JIT mode, the XLA CPU backend emits code for the host CPU. For ahead-of-time compilation, <code>xla::AotCompilationOptions</code> can provide an LLVM triple to configure the target architecture.</p> <p>If there is no existing LLVM backend but another kind of code generator exists, it should be possible to reuse most of the existing CPU backend.</p>"},{"location":"developing_new_backend/#scenario-2-non-cpu-like-hardware-with-an-existing-llvm-backend","title":"Scenario 2: Non-CPU-like hardware with an existing LLVM backend","text":"<p>It is possible to model a new <code>xla::Compiler</code> implementation on the existing <code>xla::CPUCompiler</code> and <code>xla::GPUCompiler</code> classes, since these already emit LLVM IR. Depending on the nature of the hardware, it is possible that many of the LLVM IR generation aspects will have to be changed, but a lot of code can be shared with the existing backends.</p> <p>A good example to follow is the GPU backend of XLA. The GPU backend targets a non-CPU-like ISA, and therefore some aspects of its code generation are unique to the GPU domain. Other kinds of hardware, e.g. DSPs like Hexagon (which has an upstream LLVM backend), can reuse parts of the LLVM IR emission logic, but other parts will be unique.</p>"},{"location":"developing_new_backend/#scenario-3-non-cpu-like-hardware-without-an-existing-llvm-backend","title":"Scenario 3: Non-CPU-like hardware without an existing LLVM backend","text":"<p>If it is not possible to utilize LLVM, then the best option is to implement a new backend for XLA for the desired hardware. This option requires the most effort. The classes that need to be implemented are as follows:</p> <ul> <li><code>StreamExecutor</code>:     For many devices not all methods of <code>StreamExecutor</code> are needed. See     existing <code>StreamExecutor</code> implementations for details.</li> <li><code>xla::Compiler</code>:     This class encapsulates the compilation of an HLO computation into an     <code>xla::Executable</code>.</li> <li><code>xla::Executable</code>:     This class is used to launch a compiled computation on the platform.</li> <li><code>xla::TransferManager</code>:     This class enables backends to provide platform-specific mechanisms for     constructing XLA literal data from given device memory handles. In other     words, it helps encapsulate the transfer of data from the host to the device     and back.</li> </ul>"},{"location":"operation_semantics/","title":"Operation Semantics","text":"<p>The following describes the semantics of operations defined in the <code>XlaBuilder</code> interface. Typically, these operations map one-to-one to operations defined in the RPC interface in <code>xla_data.proto</code>.</p> <p>A note on nomenclature: the generalized data type XLA deals with is an N-dimensional array holding elements of some uniform type (such as 32-bit float). Throughout the documentation, array is used to denote an arbitrary-dimensional array. For convenience, special cases have more specific and familiar names; for example a vector is a 1-dimensional array and a matrix is a 2-dimensional array.</p>"},{"location":"operation_semantics/#afterall","title":"AfterAll","text":"<p>See also <code>XlaBuilder::AfterAll</code>.</p> <p>AfterAll takes a variadic number of tokens and produces a single token. Tokens are primitive types which can be threaded between side-effecting operations to enforce ordering. <code>AfterAll</code> can be used as a join of tokens for ordering a operation after a set operations.</p> <p> <code>AfterAll(operands)</code> </p>    Arguments Type Semantics     <code>operands</code> <code>XlaOp</code> variadic number of tokens"},{"location":"operation_semantics/#allgather","title":"AllGather","text":"<p>See also <code>XlaBuilder::AllGather</code>.</p> <p>Performs concatenation across replicas.</p> <p> <code>AllGather(operand, all_gather_dim, shard_count, replica_group_ids, channel_id)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> Array to concatenate across replicas.   <code>all_gather_dim</code> <code>int64</code> Concatenation dimension.   <code>replica_groups</code> vector of vectors of <code>int64</code> Groups between which the concatenation is performed.   <code>channel_id</code> optional <code>int64</code> Optional channel ID for cross-module communication.    <ul> <li><code>replica_groups</code> is a list of replica groups between which the concatenation     is performed (replica id for the current replica can be retrieved using     <code>ReplicaId</code>). The order of replicas in each group determines     the order in which their inputs are located in the result. <code>replica_groups</code>     must either be empty (in which case all replicas belong to a single group,     ordered from <code>0</code> to <code>N - 1</code>), or contain the same number of elements as the     number of replicas. For example, <code>replica_groups = {0, 2}, {1, 3}</code> performs     concatenation between the replicas <code>0</code> and <code>2</code>, and <code>1</code> and <code>3</code>.</li> <li><code>shard_count</code> is the size of each replica group. We need this in cases where     <code>replica_groups</code> are empty.</li> <li><code>channel_id</code> is used for cross-module communication: only <code>all-gather</code>     operations with the same <code>channel_id</code> can communicate to each other.</li> </ul> <p>The output shape is the input shape with the <code>all_gather_dim</code> made <code>shard_count</code> times larger. For example, if there are two replicas and the operand has the value <code>[1.0, 2.5]</code> and <code>[3.0, 5.25]</code> respectively on the two replicas, then the output value from this op where <code>all_gather_dim</code> is <code>0</code> will be <code>[1.0, 2.5, 3.0, 5.25]</code> on both replicas.</p>"},{"location":"operation_semantics/#allreduce","title":"AllReduce","text":"<p>See also <code>XlaBuilder::AllReduce</code>.</p> <p>Performs a custom computation across replicas.</p> <p> <code>AllReduce(operand, computation, replica_group_ids, channel_id)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> Array or a non-empty tuple of arrays to reduce across replicas.   <code>computation</code> <code>XlaComputation</code> Reduction computation   <code>replica_groups</code> vector of vectors of <code>int64</code> Groups between which the reductions are performed   <code>channel_id</code> optional <code>int64</code> Optional channel ID for cross-module communication    <ul> <li>When <code>operand</code> is a tuple of arrays, the all-reduce is performed on each     element of the tuple.</li> <li><code>replica_groups</code> is a list of replica groups between which the reduction is     performed (replica id for the current replica can be retrieved using     <code>ReplicaId</code>). <code>replica_groups</code> must either be empty (in which     case all replicas belong to a single group), or contain the same number of     elements as the number of replicas. For example, <code>replica_groups = {0, 2},     {1, 3}</code> performs reduction between the replicas <code>0</code> and <code>2</code>, and <code>1</code> and     <code>3</code>.</li> <li><code>channel_id</code> is used for cross-module communication: only <code>all-reduce</code>     operations with the same <code>channel_id</code> can communicate to each other.</li> </ul> <p>The output shape is the same as the input shape. For example, if there are two replicas and the operand has the value <code>[1.0, 2.5]</code> and <code>[3.0, 5.25]</code> respectively on the two replicas, then the output value from this op and summation computation will be <code>[4.0, 7.75]</code> on both replicas. If the input is a tuple, the output is a tuple as well.</p> <p>Computing the result of <code>AllReduce</code> requires having one input from each replica, so if one replica executes a <code>AllReduce</code> node more times than another, then the former replica will wait forever. Since the replicas are all running the same program, there are not a lot of ways for that to happen, but it is possible when a while loop's condition depends on data from infeed and the data that is infed causes the while loop to iterate more times on one replica than another.</p>"},{"location":"operation_semantics/#alltoall","title":"AllToAll","text":"<p>See also <code>XlaBuilder::AllToAll</code>.</p> <p>AllToAll is a collective operation that sends data from all cores to all cores. It has two phases:</p> <ol> <li>The scatter phase. On each core, the operand is split into <code>split_count</code>     number of blocks along the <code>split_dimensions</code>, and the blocks are scattered     to all cores, e.g., the ith block is send to the ith core.</li> <li>The gather phase. Each core concatenates the received blocks along the     <code>concat_dimension</code>.</li> </ol> <p>The participating cores can be configured by:</p> <ul> <li><code>replica_groups</code>: each ReplicaGroup contains a list of replica id     participating in the computation (replica id for the current replica can be     retrieved using <code>ReplicaId</code>). AllToAll will be applied within     subgroups in the specified order. For example, <code>replica_groups = {{1,2,3},     {4,5,0}}</code> means that an AllToAll will be applied within replicas <code>{1, 2,     3}</code>, and in the gather phase, and the received blocks will be concatenated     in the same order of 1, 2, 3. Then, another AllToAll will be applied within     replicas 4, 5, 0, and the concatenation order is also 4, 5, 0. If     <code>replica_groups</code> is empty, all replicas belong to one group, in the     concatenation order of their appearance.</li> </ul> <p>Prerequisites:</p> <ul> <li>The dimension size of the operand on the <code>split_dimension</code> is divisible by <code>split_count</code>.</li> <li>The operand's shape is not tuple.</li> </ul> <p> <code>AllToAll(operand, split_dimension, concat_dimension, split_count, replica_groups)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional input array   <code>split_dimension</code> <code>int64</code> A value in the interval <code>[0, n)</code> that names the dimension along which the operand is split   <code>concat_dimension</code> <code>int64</code> a value in the interval <code>[0, n)</code> that names the dimension along which the split blocks are concatenated   <code>split_count</code> <code>int64</code> the number of cores that participate this operation. If <code>replica_groups</code> is empty, this should be the number of replicas; otherwise, this should be equal to the number of replicas in each group.   <code>replica_groups</code> <code>ReplicaGroup</code> vector each group contains a list of replica id.    <p>Below shows an example of Alltoall.</p> <pre><code>XlaBuilder b(\"alltoall\");\nauto x = Parameter(&amp;b, 0, ShapeUtil::MakeShape(F32, {4, 16}), \"x\");\nAllToAll(x, /*split_dimension=*/1, /*concat_dimension=*/0, /*split_count=*/4);\n</code></pre>  <p>In this example, there are 4 cores participating the Alltoall. On each core, the operand is split into 4 parts along dimension 0, so each part has shape f32[4,4]. The 4 parts are scattered to all cores. Then each core concatenates the received parts along dimension 1, in the order or core 0-4. So the output on each core has shape f32[16,4].</p>"},{"location":"operation_semantics/#batchnormgrad","title":"BatchNormGrad","text":"<p>See also <code>XlaBuilder::BatchNormGrad</code> and the original batch normalization paper for a detailed description of the algorithm.</p> <p>Calculates gradients of batch norm.</p> <p> <code>BatchNormGrad(operand, scale, mean, variance, grad_output, epsilon, feature_index)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional array to be normalized (x)   <code>scale</code> <code>XlaOp</code> 1 dimensional array (\\(\\gamma\\))   <code>mean</code> <code>XlaOp</code> 1 dimensional array (\\(\\mu\\))   <code>variance</code> <code>XlaOp</code> 1 dimensional array (\\(\\sigma^2\\))   <code>grad_output</code> <code>XlaOp</code> Gradients passed to <code>BatchNormTraining</code> (\\( \\nabla y\\))   <code>epsilon</code> <code>float</code> Epsilon value (\\(\\epsilon\\))   <code>feature_index</code> <code>int64</code> Index to feature dimension in <code>operand</code>    <p>For each feature in the feature dimension (<code>feature_index</code> is the index for the feature dimension in <code>operand</code>), the operation calculates the gradients with respect to <code>operand</code>, <code>offset</code> and <code>scale</code> across all the other dimensions. The <code>feature_index</code> must be a valid index for the feature dimension in <code>operand</code>.</p> <p>The three gradients are defined by the following formulas (assuming a 4-dimensional array as <code>operand</code> and with feature dimension index <code>l</code>, batch size <code>m</code> and spatial sizes <code>w</code> and <code>h</code>):</p> <p>\\[ \\begin{split} c_l&amp;= \\frac{1}{mwh}\\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h \\left( \\nabla y_{ijkl} \\frac{x_{ijkl} - \\mu_l}{\\sigma^2_l+\\epsilon} \\right) \\\\ d_l&amp;= \\frac{1}{mwh}\\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h \\nabla y_{ijkl} \\\\ \\nabla x_{ijkl} &amp;= \\frac{\\gamma_{l}}{\\sqrt{\\sigma^2_{l}+\\epsilon}} \\left( \\nabla y_{ijkl} - d_l - c_l (x_{ijkl} - \\mu_{l}) \\right) \\\\ \\nabla \\gamma_l &amp;= \\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h \\left( \\nabla y_{ijkl} \\frac{x_{ijkl} - \\mu_l}{\\sqrt{\\sigma^2_{l}+\\epsilon}} \\right) \\\\\\ \\nabla \\beta_l &amp;= \\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h \\nabla y_{ijkl} \\end{split} \\]</p> <p>The inputs <code>mean</code> and <code>variance</code> represent moments value across batch and spatial dimensions.</p> <p>The output type is a tuple of three handles:</p>    Outputs Type Semantics     <code>grad_operand</code> <code>XlaOp</code> gradient with respect to input <code>operand</code> (\\( \\nabla x\\))   <code>grad_scale</code> <code>XlaOp</code> gradient with respect to input <code>scale</code> (\\( \\nabla \\gamma\\))   <code>grad_offset</code> <code>XlaOp</code> gradient with respect to input <code>offset</code>(\\( \\nabla \\beta\\))"},{"location":"operation_semantics/#batchnorminference","title":"BatchNormInference","text":"<p>See also <code>XlaBuilder::BatchNormInference</code> and the original batch normalization paper for a detailed description of the algorithm.</p> <p>Normalizes an array across batch and spatial dimensions.</p> <p> <code>BatchNormInference(operand, scale, offset, mean, variance, epsilon, feature_index)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional array to be normalized   <code>scale</code> <code>XlaOp</code> 1 dimensional array   <code>offset</code> <code>XlaOp</code> 1 dimensional array   <code>mean</code> <code>XlaOp</code> 1 dimensional array   <code>variance</code> <code>XlaOp</code> 1 dimensional array   <code>epsilon</code> <code>float</code> Epsilon value   <code>feature_index</code> <code>int64</code> Index to feature dimension in <code>operand</code>    <p>For each feature in the feature dimension (<code>feature_index</code> is the index for the feature dimension in <code>operand</code>), the operation calculates the mean and variance across all the other dimensions and uses the mean and variance to normalize each element in <code>operand</code>. The <code>feature_index</code> must be a valid index for the feature dimension in <code>operand</code>.</p> <p><code>BatchNormInference</code>  is equivalent to calling <code>BatchNormTraining</code> without computing <code>mean</code> and <code>variance</code> for each batch. It uses the input <code>mean</code> and <code>variance</code> instead as estimated values. The purpose of this op is to reduce latency in inference, hence the name <code>BatchNormInference</code>.</p> <p>The output is an n-dimensional, normalized array with the same shape as input <code>operand</code>.</p>"},{"location":"operation_semantics/#batchnormtraining","title":"BatchNormTraining","text":"<p>See also <code>XlaBuilder::BatchNormTraining</code> and <code>the original batch normalization paper</code> for a detailed description of the algorithm.</p> <p>Normalizes an array across batch and spatial dimensions.</p> <p> <code>BatchNormTraining(operand, scale, offset, epsilon, feature_index)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional array to be normalized (x)   <code>scale</code> <code>XlaOp</code> 1 dimensional array (\\(\\gamma\\))   <code>offset</code> <code>XlaOp</code> 1 dimensional array (\\(\\beta\\))   <code>epsilon</code> <code>float</code> Epsilon value (\\(\\epsilon\\))   <code>feature_index</code> <code>int64</code> Index to feature dimension in <code>operand</code>    <p>For each feature in the feature dimension (<code>feature_index</code> is the index for the feature dimension in <code>operand</code>), the operation calculates the mean and variance across all the other dimensions and uses the mean and variance to normalize each element in <code>operand</code>. The <code>feature_index</code> must be a valid index for the feature dimension in <code>operand</code>.</p> <p>The algorithm goes as follows for each batch in <code>operand</code> \\(x\\) that contains <code>m</code> elements with <code>w</code> and <code>h</code> as the size of spatial dimensions (assuming <code>operand</code> is an 4 dimensional array):</p> <ul> <li> <p>Calculates batch mean \\(\\mu_l\\) for each feature <code>l</code> in feature dimension: \\(\\mu_l=\\frac{1}{mwh}\\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h x_{ijkl}\\)</p> </li> <li> <p>Calculates batch variance \\(\\sigma^2_l\\): \\(\\sigma^2_l=\\frac{1}{mwh}\\sum_{i=1}^m\\sum_{j=1}^w\\sum_{k=1}^h (x_{ijkl} - \\mu_l)^2\\)</p> </li> <li> <p>Normalizes, scales and shifts: \\(y_{ijkl}=\\frac{\\gamma_l(x_{ijkl}-\\mu_l)}{\\sqrt[2]{\\sigma^2_l+\\epsilon}}+\\beta_l\\)</p> </li> </ul> <p>The epsilon value, usually a small number, is added to avoid divide-by-zero errors.</p> <p>The output type is a tuple of three <code>XlaOp</code>s:</p>    Outputs Type Semantics     <code>output</code> <code>XlaOp</code> n dimensional array with the same shape as input <code>operand</code> (y)   <code>batch_mean</code> <code>XlaOp</code> 1 dimensional array (\\(\\mu\\))   <code>batch_var</code> <code>XlaOp</code> 1 dimensional array (\\(\\sigma^2\\))    <p>The <code>batch_mean</code> and <code>batch_var</code> are moments calculated across the batch and spatial dimensions using the formulas above.</p>"},{"location":"operation_semantics/#bitcastconverttype","title":"BitcastConvertType","text":"<p>See also <code>XlaBuilder::BitcastConvertType</code>.</p> <p>Similar to a <code>tf.bitcast</code> in TensorFlow, performs an element-wise bitcast operation from a data shape to a target shape. The input and output size must match: e.g. <code>s32</code> elements become <code>f32</code> elements via bitcast routine, and one <code>s32</code> element will become four <code>s8</code> elements. Bitcast is implemented as a low-level cast, so machines with different floating-point representations will give different results.</p> <p> <code>BitcastConvertType(operand, new_element_type)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T with dims D   <code>new_element_type</code> <code>PrimitiveType</code> type U    <p>The dimensions of the operand and the target shape must match, apart from the last dimension which will change by the ratio of the primitive size before and after the conversion.</p> <p>The source and destination element types must not be tuples.</p>"},{"location":"operation_semantics/#bitcast-converting-to-primitive-type-of-different-width","title":"Bitcast-converting to primitive type of different width","text":"<p><code>BitcastConvert</code> HLO instruction supports the case where the size of the output element type <code>T'</code> is not equal to the size of the input element <code>T</code>. As the whole operation is conceptually a bitcast and does not change the underlying bytes, the shape of the output element has to change. For <code>B = sizeof(T), B' = sizeof(T')</code>, there are two possible cases.</p> <p>First, when <code>B &gt; B'</code>, the output shape gets a new minor-most dimension of size <code>B/B'</code>. For example:</p> <pre><code>  f16[10,2]{1,0} %output = f16[10,2]{1,0} bitcast-convert(f32[10]{0} %input)\n</code></pre> <p>The rule remains the same for effective scalars:</p> <pre><code>  f16[2]{0} %output = f16[2]{0} bitcast-convert(f32[] %input)\n</code></pre> <p>Alternatively, for <code>B' &gt; B</code> the instruction requires the last logical dimension of the input shape to be equal to <code>B'/B</code>, and this dimension is dropped during the conversion:</p> <pre><code>  f32[10]{0} %output = f32[10]{0} bitcast-convert(f16[10,2]{1,0} %input)\n</code></pre> <p>Note that conversions between different bitwidths are not elementwise.</p>"},{"location":"operation_semantics/#broadcast","title":"Broadcast","text":"<p>See also <code>XlaBuilder::Broadcast</code>.</p> <p>Adds dimensions to an array by duplicating the data in the array.</p> <p> <code>Broadcast(operand, broadcast_sizes)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The array to duplicate   <code>broadcast_sizes</code> <code>ArraySlice&lt;int64&gt;</code> The sizes of the new dimensions    <p>The new dimensions are inserted on the left, i.e. if <code>broadcast_sizes</code> has values <code>{a0, ..., aN}</code> and the operand shape has dimensions <code>{b0, ..., bM}</code> then the shape of the output has dimensions <code>{a0, ..., aN, b0, ..., bM}</code>.</p> <p>The new dimensions index into copies of the operand, i.e.</p> <pre><code>output[i0, ..., iN, j0, ..., jM] = operand[j0, ..., jM]\n</code></pre> <p>For example, if <code>operand</code> is a scalar <code>f32</code> with value <code>2.0f</code>, and <code>broadcast_sizes</code> is <code>{2, 3}</code>, then the result will be an array with shape <code>f32[2, 3]</code> and all the values in the result will be <code>2.0f</code>.</p>"},{"location":"operation_semantics/#broadcastindim","title":"BroadcastInDim","text":"<p>See also <code>XlaBuilder::BroadcastInDim</code>.</p> <p>Expands the size and rank of an array by duplicating the data in the array.</p> <p> <code>BroadcastInDim(operand, out_dim_size, broadcast_dimensions)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The array to duplicate   <code>out_dim_size</code> <code>ArraySlice&lt;int64&gt;</code> The sizes of the dimensions of the target shape   <code>broadcast_dimensions</code> <code>ArraySlice&lt;int64&gt;</code> Which dimension in the target shape each dimension of the operand shape corresponds to    <p>Similar to Broadcast, but allows adding dimensions anywhere and expanding existing dimensions with size 1.</p> <p>The <code>operand</code> is broadcast to the shape described by <code>out_dim_size</code>. <code>broadcast_dimensions</code> maps the dimensions of <code>operand</code> to the dimensions of the target shape, i.e. the i'th dimension of the operand is mapped to the broadcast_dimension[i]'th dimension of the output shape. The dimensions of <code>operand</code> must have size 1 or be the same size as the dimension in the output shape they are mapped to. The remaining dimensions are filled with dimensions of size 1. Degenerate-dimension broadcasting then broadcasts along these degenerate dimensions to reach the output shape. The semantics are described in detail on the broadcasting page.</p>"},{"location":"operation_semantics/#call","title":"Call","text":"<p>See also <code>XlaBuilder::Call</code>.</p> <p>Invokes a computation with the given arguments.</p> <p> <code>Call(computation, args...)</code> </p>    Arguments Type Semantics     <code>computation</code> <code>XlaComputation</code> computation of type <code>T_0, T_1, ..., T_{N-1} -&gt; S</code> with N parameters of arbitrary type   <code>args</code> sequence of N <code>XlaOp</code>s N arguments of arbitrary type    <p>The arity and types of the <code>args</code> must match the parameters of the <code>computation</code>. It is allowed to have no <code>args</code>.</p>"},{"location":"operation_semantics/#cholesky","title":"Cholesky","text":"<p>See also <code>XlaBuilder::Cholesky</code>.</p> <p>Computes the Cholesky decomposition of a batch of symmetric (Hermitian) positive definite matrices.</p> <p> <code>Cholesky(a, lower)</code> </p>    Arguments Type Semantics     <code>a</code> <code>XlaOp</code> a rank &gt; 2 array of a complex or floating-point type.   <code>lower</code> <code>bool</code> whether to use the upper or lower triangle of <code>a</code>.    <p>If <code>lower</code> is <code>true</code>, computes lower-triangular matrices <code>l</code> such that \\(a = l . l^T\\). If <code>lower</code> is <code>false</code>, computes upper-triangular matrices <code>u</code> such that \\(a = u^T . u\\).</p> <p>Input data is read only from the lower/upper triangle of <code>a</code>, depending on the value of <code>lower</code>. Values from the other triangle are ignored. Output data is returned in the same triangle; the values in the other triangle are implementation-defined and may be anything.</p> <p>If the rank of <code>a</code> is greater than 2, <code>a</code> is treated as a batch of matrices, where all except the minor 2 dimensions are batch dimensions.</p> <p>If <code>a</code> is not symmetric (Hermitian) positive definite, the result is implementation-defined.</p>"},{"location":"operation_semantics/#clamp","title":"Clamp","text":"<p>See also <code>XlaBuilder::Clamp</code>.</p> <p>Clamps an operand to within the range between a minimum and maximum value.</p> <p> <code>Clamp(min, operand, max)</code> </p>    Arguments Type Semantics     <code>min</code> <code>XlaOp</code> array of type T   <code>operand</code> <code>XlaOp</code> array of type T   <code>max</code> <code>XlaOp</code> array of type T    <p>Given an operand and minimum and maximum values, returns the operand if it is in the range between the minimum and maximum, else returns the minimum value if the operand is below this range or the maximum value if the operand is above this range.  That is, <code>clamp(a, x, b) =  min(max(a, x), b)</code>.</p> <p>All three arrays must be the same shape. Alternatively, as a restricted form of broadcasting, <code>min</code> and/or <code>max</code> can be a scalar of type <code>T</code>.</p> <p>Example with scalar <code>min</code> and <code>max</code>:</p> <pre><code>let operand: s32[3] = {-1, 5, 9};\nlet min: s32 = 0;\nlet max: s32 = 6;\n==&gt;\nClamp(min, operand, max) = s32[3]{0, 5, 6};\n</code></pre>"},{"location":"operation_semantics/#collapse","title":"Collapse","text":"<p>See also <code>XlaBuilder::Collapse</code> and the <code>tf.reshape</code> operation.</p> <p>Collapses dimensions of an array into one dimension.</p> <p> <code>Collapse(operand, dimensions)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T   <code>dimensions</code> <code>int64</code> vector in-order, consecutive subset of T's dimensions.    <p>Collapse replaces the given subset of the operand's dimensions by a single dimension. The input arguments are an arbitrary array of type T and a compile-time-constant vector of dimension indices. The dimension indices must be an in-order (low to high dimension numbers), consecutive subset of T's dimensions. Thus, {0, 1, 2}, {0, 1}, or {1, 2} are all valid dimension sets, but {1, 0} or {0, 2} are not. They are replaced by a single new dimension, in the same position in the dimension sequence as those they replace, with the new dimension size equal to the product of original dimension sizes. The lowest dimension number in <code>dimensions</code> is the slowest varying dimension (most major) in the loop nest which collapses these dimension, and the highest dimension number is fastest varying (most minor). See the <code>tf.reshape</code> operator if more general collapse ordering is needed.</p> <p>For example, let v be an array of 24 elements:</p> <pre><code>let v = f32[4x2x3] {{{10, 11, 12},  {15, 16, 17}},\n{{20, 21, 22},  {25, 26, 27}},\n{{30, 31, 32},  {35, 36, 37}},\n{{40, 41, 42},  {45, 46, 47}}};\n\n// Collapse to a single dimension, leaving one dimension.\nlet v012 = Collapse(v, {0,1,2});\nthen v012 == f32[24] {10, 11, 12, 15, 16, 17,\n20, 21, 22, 25, 26, 27,\n30, 31, 32, 35, 36, 37,\n40, 41, 42, 45, 46, 47};\n\n// Collapse the two lower dimensions, leaving two dimensions.\nlet v01 = Collapse(v, {0,1});\nthen v01 == f32[4x6] {{10, 11, 12, 15, 16, 17},\n{20, 21, 22, 25, 26, 27},\n{30, 31, 32, 35, 36, 37},\n{40, 41, 42, 45, 46, 47}};\n\n// Collapse the two higher dimensions, leaving two dimensions.\nlet v12 = Collapse(v, {1,2});\nthen v12 == f32[8x3] {{10, 11, 12},\n{15, 16, 17},\n{20, 21, 22},\n{25, 26, 27},\n{30, 31, 32},\n{35, 36, 37},\n{40, 41, 42},\n{45, 46, 47}};\n</code></pre>"},{"location":"operation_semantics/#collectivepermute","title":"CollectivePermute","text":"<p>See also <code>XlaBuilder::CollectivePermute</code>.</p> <p>CollectivePermute is a collective operation that sends and receives data cross replicas.</p> <p> <code>CollectivePermute(operand, source_target_pairs)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional input array   <code>source_target_pairs</code> <code>&lt;int64, int64&gt;</code> vector A list of (source_replica_id, target_replica_id) pairs. For each pair, the operand is sent from source replica to target replica.    <p>Note that there are the following restrictions on the <code>source_target_pair</code>:</p> <ul> <li>Any two pairs should not have the same target replica id, and they should not have the same source replica id.</li> <li>If a replica id is not a target in any pair, then the output on that replica is a tensor consists of 0(s) with the same shape as the input.</li> </ul>"},{"location":"operation_semantics/#concatenate","title":"Concatenate","text":"<p>See also <code>XlaBuilder::ConcatInDim</code>.</p> <p>Concatenate composes an array from multiple array operands. The array is of the same rank as each of the input array operands (which must be of the same rank as each other) and contains the arguments in the order that they were specified.</p> <p> <code>Concatenate(operands..., dimension)</code> </p>    Arguments Type Semantics     <code>operands</code> sequence of N <code>XlaOp</code> N arrays of type T with dimensions [L0, L1, ...]. Requires N &gt;= 1.   <code>dimension</code> <code>int64</code> A value in the interval <code>[0, N)</code> that names the dimension to be concatenated between the <code>operands</code>.    <p>With the exception of <code>dimension</code> all dimensions must be the same. This is because XLA does not support \"ragged\" arrays. Also note that rank-0 values cannot be concatenated (as it's impossible to name the dimension along which the concatenation occurs).</p> <p>1-dimensional example:</p> <pre><code>Concat({{2, 3}, {4, 5}, {6, 7}}, 0)\n&gt;&gt;&gt; {2, 3, 4, 5, 6, 7}\n</code></pre> <p>2-dimensional example:</p> <pre><code>let a = {\n{1, 2},\n{3, 4},\n{5, 6},\n};\nlet b = {\n{7, 8},\n};\nConcat({a, b}, 0)\n&gt;&gt;&gt; {\n{1, 2},\n{3, 4},\n{5, 6},\n{7, 8},\n}\n</code></pre> <p>Diagram:</p>"},{"location":"operation_semantics/#conditional","title":"Conditional","text":"<p>See also <code>XlaBuilder::Conditional</code>.</p> <p> <code>Conditional(pred, true_operand, true_computation, false_operand, false_computation)</code> </p>     Arguments Type Semantics     <code>pred</code> <code>XlaOp</code> Scalar of type <code>PRED</code>   <code>true_operand</code> <code>XlaOp</code> Argument of type \\(T_0\\)   <code>true_computation</code> <code>XlaComputation</code> XlaComputation of type \\(T_0 \\to S\\)   <code>false_operand</code> <code>XlaOp</code> Argument of type \\(T_1\\)   <code>false_computation</code> <code>XlaComputation</code> XlaComputation of type \\(T_1 \\to S\\)    <p>Executes <code>true_computation</code> if <code>pred</code> is <code>true</code>, <code>false_computation</code> if <code>pred</code> is <code>false</code>, and returns the result.</p> <p>The <code>true_computation</code> must take in a single argument of type \\(T_0\\) and will be invoked with <code>true_operand</code> which must be of the same type. The <code>false_computation</code> must take in a single argument of type \\(T_1\\) and will be invoked with <code>false_operand</code> which must be of the same type. The type of the returned value of <code>true_computation</code> and <code>false_computation</code> must be the same.</p>  <p>Note that only one of <code>true_computation</code> and <code>false_computation</code> will be executed depending on the value of <code>pred</code>.</p> <p> <code>Conditional(branch_index, branch_computations, branch_operands)</code> </p>     Arguments Type Semantics     <code>branch_index</code> <code>XlaOp</code> Scalar of type <code>S32</code>   <code>branch_computations</code> sequence of N <code>XlaComputation</code> XlaComputations of type \\( T_0 \\to S , T_1 \\to S , ..., T_{N-1} \\to S \\)   <code>branch_operands</code> sequence of N <code>XlaOp</code> Arguments of type \\( T_0 , T_1 , ..., T_{N-1} \\)     <p>Executes <code>branch_computations[branch_index]</code>, and returns the result. If <code>branch_index</code> is an <code>S32</code> which is &lt; 0 or &gt;= N, then <code>branch_computations[N-1]</code> is executed as the default branch.</p> <p>Each <code>branch_computations[b]</code> must take in a single argument of type <code>T_b</code> and will be invoked with <code>branch_operands[b]</code> which must be of the same type. The type of the returned value of each <code>branch_computations[b]</code> must be the same.</p> <p>Note that only one of the <code>branch_computations</code> will be executed depending on the value of <code>branch_index</code>.</p>"},{"location":"operation_semantics/#conv-convolution","title":"Conv (convolution)","text":"<p>See also <code>XlaBuilder::Conv</code>.</p> <p>As ConvWithGeneralPadding, but the padding is specified in a short-hand way as either SAME or VALID. SAME padding pads the input (<code>lhs</code>) with zeroes so that the output has the same shape as the input when not taking striding into account. VALID padding simply means no padding.</p>"},{"location":"operation_semantics/#convwithgeneralpadding-convolution","title":"ConvWithGeneralPadding (convolution)","text":"<p>See also <code>XlaBuilder::ConvWithGeneralPadding</code>.</p> <p>Computes a convolution of the kind used in neural networks. Here, a convolution can be thought of as a n-dimensional window moving across a n-dimensional base area and a computation is performed for each possible position of the window.</p>    Arguments Type Semantics     <code>lhs</code> <code>XlaOp</code> rank n+2 array of inputs   <code>rhs</code> <code>XlaOp</code> rank n+2 array of kernel weights   <code>window_strides</code> <code>ArraySlice&lt;int64&gt;</code> n-d array of kernel strides   <code>padding</code> <code>ArraySlice&lt; pair&lt;int64,int64&gt;&gt;</code> n-d array of (low, high) padding   <code>lhs_dilation</code> <code>ArraySlice&lt;int64&gt;</code> n-d lhs dilation factor array   <code>rhs_dilation</code> <code>ArraySlice&lt;int64&gt;</code> n-d rhs dilation factor array   <code>feature_group_count</code> int64 the number of feature groups   <code>batch_group_count</code> int64 the number of batch groups    <p>Let n be the number of spatial dimensions. The <code>lhs</code> argument is a rank n+2 array describing the base area. This is called the input, even though of course the rhs is also an input. In a neural network, these are the input activations. The n+2 dimensions are, in this order:</p> <ul> <li><code>batch</code>: Each coordinate in this dimension represents an independent input for which convolution is carried out.</li> <li><code>z/depth/features</code>: Each (y,x) position in the base area has a vector associated to it, which goes into this dimension.</li> <li><code>spatial_dims</code>: Describes the <code>n</code> spatial dimensions that define the base area that the window moves across.</li> </ul> <p>The <code>rhs</code> argument is a rank n+2 array describing the convolutional filter/kernel/window. The dimensions are, in this order:</p> <ul> <li><code>output-z</code>: The <code>z</code> dimension of the output.</li> <li><code>input-z</code>: The size of this dimension times <code>feature_group_count</code> should equal the size of the <code>z</code> dimension in lhs.</li> <li><code>spatial_dims</code>: Describes the <code>n</code> spatial dimensions that define the n-d window that moves across the base area.</li> </ul> <p>The <code>window_strides</code> argument specifies the stride of the convolutional window in the spatial dimensions. For example, if the stride in the first spatial dimension is 3, then the window can only be placed at coordinates where the first spatial index is divisible by 3.</p> <p>The <code>padding</code> argument specifies the amount of zero padding to be applied to the base area. The amount of padding can be negative -- the absolute value of negative padding indicates the number of elements to remove from the specified dimension before doing the convolution. <code>padding[0]</code> specifies the padding for dimension <code>y</code> and <code>padding[1]</code> specifies the padding for dimension <code>x</code>. Each pair has the low padding as the first element and the high padding as the second element. The low padding is applied in the direction of lower indices while the high padding is applied in the direction of higher indices. For example, if <code>padding[1]</code> is <code>(2,3)</code> then there will be a padding by 2 zeroes on the left and by 3 zeroes on the right in the second spatial dimension. Using padding is equivalent to inserting those same zero values into the input (<code>lhs</code>) before doing the convolution.</p> <p>The <code>lhs_dilation</code> and <code>rhs_dilation</code> arguments specify the dilation factor to be applied to the lhs and rhs, respectively, in each spatial dimension. If the dilation factor in a spatial dimension is d, then d-1 holes are implicitly placed between each of the entries in that dimension, increasing the size of the array. The holes are filled with a no-op value, which for convolution means zeroes.</p> <p>Dilation of the rhs is also called atrous convolution. For more details, see <code>tf.nn.atrous_conv2d</code>. Dilation of the lhs is also called transposed convolution. For more details, see <code>tf.nn.conv2d_transpose</code>.</p> <p>The <code>feature_group_count</code> argument (default value 1) can be used for grouped convolutions. <code>feature_group_count</code> needs to be a divisor of both the input and the output feature dimension. If <code>feature_group_count</code> is greater than 1, it means that conceptually the input and output feature dimension and the <code>rhs</code> output feature dimension are split evenly into <code>feature_group_count</code> many groups, each group consisting of a consecutive subsequence of features. The input feature dimension of <code>rhs</code> needs to be equal to the <code>lhs</code> input feature dimension divided by <code>feature_group_count</code> (so it already has the size of a group of input features). The i-th groups are used together to compute <code>feature_group_count</code> many separate convolutions. The results of these convolutions are concatenated together in the output feature dimension.</p> <p>For depthwise convolution the <code>feature_group_count</code> argument would be set to the input feature dimension, and the filter would be reshaped from <code>[filter_height, filter_width, in_channels, channel_multiplier]</code> to <code>[filter_height, filter_width, 1, in_channels * channel_multiplier]</code>. For more details, see <code>tf.nn.depthwise_conv2d</code>.</p> <p>The <code>batch_group_count</code> (default value 1) argument can be used for grouped filters during backpropagation. <code>batch_group_count</code> needs to be a divisor of the size of the <code>lhs</code> (input) batch dimension. If <code>batch_group_count</code> is greater than 1, it means that the output batch dimension should be of size <code>input batch / batch_group_count</code>. The <code>batch_group_count</code> must be a divisor of the output feature size.</p> <p>The output shape has these dimensions, in this order:</p> <ul> <li><code>batch</code>: The size of this dimension times <code>batch_group_count</code> should equal     the size of the <code>batch</code> dimension in lhs.</li> <li><code>z</code>: Same size as <code>output-z</code> on the kernel (<code>rhs</code>).</li> <li><code>spatial_dims</code>: One value for each valid placement of the convolutional     window.</li> </ul>  <p>The figure above shows how <code>batch_group_count</code> field works. Effectively, we slice each lhs batch into <code>batch_group_count</code> groups, and do the same for the output features. Then, for each of these groups we do pairwise convolutions and concatenate the output along the output feature dimension. The operational semantics of all the other dimensions (feature and spatial) remain the same.</p> <p>The valid placements of the convolutional window are determined by the strides and the size of the base area after padding.</p> <p>To describe what a convolution does, consider a 2d convolution, and pick some fixed <code>batch</code>, <code>z</code>, <code>y</code>, <code>x</code> coordinates in the output. Then <code>(y,x)</code> is a position of a corner of the window within the base area (e.g. the upper left corner, depending on how you interpret the spatial dimensions). We now have a 2d window, taken from the base area, where each 2d point is associated to a 1d vector, so we get a 3d box. From the convolutional kernel, since we fixed the output coordinate <code>z</code>, we also have a 3d box. The two boxes have the same dimensions, so we can take the sum of the element-wise products between the two boxes (similar to a dot product). That is the output value.</p> <p>Note that if <code>output-z</code> is e.g., 5, then each position of the window produces 5 values in the output into the <code>z</code> dimension of the output. These values differ in what part of the convolutional kernel is used - there is a separate 3d box of values used for each <code>output-z</code> coordinate. So you could think of it as 5 separate convolutions with a different filter for each of them.</p> <p>Here is pseudo-code for a 2d convolution with padding and striding:</p> <pre><code>for (b, oz, oy, ox) {  // output coordinates\n  value = 0;\n  for (iz, ky, kx) {  // kernel coordinates and input z\n    iy = oy*stride_y + ky - pad_low_y;\n    ix = ox*stride_x + kx - pad_low_x;\n    if ((iy, ix) inside the base area considered without padding) {\n      value += input(b, iz, iy, ix) * kernel(oz, iz, ky, kx);\n    }\n  }\n  output(b, oz, oy, ox) = value;\n}\n</code></pre>"},{"location":"operation_semantics/#convertelementtype","title":"ConvertElementType","text":"<p>See also <code>XlaBuilder::ConvertElementType</code>.</p> <p>Similar to an element-wise <code>static_cast</code> in C++, performs an element-wise conversion operation from a data shape to a target shape. The dimensions must match, and the conversion is an element-wise one; e.g. <code>s32</code> elements become <code>f32</code> elements via an <code>s32</code>-to-<code>f32</code> conversion routine.</p> <p> <code>ConvertElementType(operand, new_element_type)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T with dims D   <code>new_element_type</code> <code>PrimitiveType</code> type U    <p>The dimensions of the operand and the target shape must match. The source and destination element types must not be tuples.</p> <p>A conversion such as <code>T=s32</code> to <code>U=f32</code> will perform a normalizing int-to-float conversion routine such as round-to-nearest-even.</p>  <p>Note: The precise float-to-int and visa-versa conversions are currently unspecified, but may become additional arguments to the convert operation in the future.  Not all possible conversions have been implemented for all targets.</p>  <pre><code>let a: s32[3] = {0, 1, 2};\nlet b: f32[3] = convert(a, f32);\nthen b == f32[3]{0.0, 1.0, 2.0}\n</code></pre>"},{"location":"operation_semantics/#crossreplicasum","title":"CrossReplicaSum","text":"<p>Performs <code>AllReduce</code> with a summation computation.</p>"},{"location":"operation_semantics/#customcall","title":"CustomCall","text":"<p>See also <code>XlaBuilder::CustomCall</code>.</p> <p>Call a user-provided function within a computation.</p> <p> <code>CustomCall(target_name, args..., shape)</code> </p>    Arguments Type Semantics     <code>target_name</code> <code>string</code> Name of the function. A call instruction will be emitted which targets this symbol name.   <code>args</code> sequence of N <code>XlaOp</code>s N arguments of arbitrary type, which will be passed to the function.   <code>shape</code> <code>Shape</code> Output shape of the function    <p>The function signature is the same, regardless of the arity or type of args:</p> <pre><code>extern \"C\" void target_name(void* out, void** in);\n</code></pre> <p>For example, if CustomCall is used as follows:</p> <pre><code>let x = f32[2] {1,2};\nlet y = f32[2x3] {{10, 20, 30}, {40, 50, 60}};\n\nCustomCall(\"myfunc\", {x, y}, f32[3x3])\n</code></pre> <p>Here is an example of an implementation of <code>myfunc</code>:</p> <pre><code>extern \"C\" void myfunc(void* out, void** in) {\n  float (&amp;x)[2] = *static_cast&lt;float(*)[2]&gt;(in[0]);\n  float (&amp;y)[2][3] = *static_cast&lt;float(*)[2][3]&gt;(in[1]);\n  EXPECT_EQ(1, x[0]);\n  EXPECT_EQ(2, x[1]);\n  EXPECT_EQ(10, y[0][0]);\n  EXPECT_EQ(20, y[0][1]);\n  EXPECT_EQ(30, y[0][2]);\n  EXPECT_EQ(40, y[1][0]);\n  EXPECT_EQ(50, y[1][1]);\n  EXPECT_EQ(60, y[1][2]);\n  float (&amp;z)[3][3] = *static_cast&lt;float(*)[3][3]&gt;(out);\n  z[0][0] = x[1] + y[1][0];\n  // ...\n}\n</code></pre> <p>The user-provided function must not have side-effects and its execution must be idempotent.</p>  <p>Note: The opaque nature of the user-provided function restricts optimization opportunities for the compiler. Try to express your computation in terms of native XLA ops whenever possible; only use CustomCall as a last resort.</p>"},{"location":"operation_semantics/#dot","title":"Dot","text":"<p>See also <code>XlaBuilder::Dot</code>.</p> <p> <code>Dot(lhs, rhs)</code> </p>    Arguments Type Semantics     <code>lhs</code> <code>XlaOp</code> array of type T   <code>rhs</code> <code>XlaOp</code> array of type T    <p>The exact semantics of this operation depend on the ranks of the operands:</p>    Input Output Semantics     vector [n] <code>dot</code> vector [n] scalar vector dot product   matrix [m x k] <code>dot</code> vector [k] vector [m] matrix-vector multiplication   matrix [m x k] <code>dot</code> matrix [k x n] matrix [m x n] matrix-matrix multiplication    <p>The operation performs sum of products over the second dimension of <code>lhs</code> (or the first if it has rank 1) and the first dimension of <code>rhs</code>. These are the \"contracted\" dimensions. The contracted dimensions of <code>lhs</code> and <code>rhs</code> must be of the same size. In practice, it can be used to perform dot products between vectors, vector/matrix multiplications or matrix/matrix multiplications.</p>"},{"location":"operation_semantics/#dotgeneral","title":"DotGeneral","text":"<p>See also <code>XlaBuilder::DotGeneral</code>.</p> <p> <code>DotGeneral(lhs, rhs, dimension_numbers)</code> </p>    Arguments Type Semantics     <code>lhs</code> <code>XlaOp</code> array of type T   <code>rhs</code> <code>XlaOp</code> array of type T   <code>dimension_numbers</code> <code>DotDimensionNumbers</code> contracting and batch dimension numbers    <p>As Dot, but allows contracting and batch dimension numbers to be specified for both the 'lhs' and 'rhs'.</p>    DotDimensionNumbers Fields Type Semantics     'lhs_contracting_dimensions' repeated int64 'lhs' contracting dimension numbers   'rhs_contracting_dimensions' repeated int64 'rhs' contracting dimension numbers   'lhs_batch_dimensions' repeated int64 'lhs' batch dimension numbers   'rhs_batch_dimensions' repeated int64 'rhs' batch dimension numbers    <p>DotGeneral performs the sum of products over contracting dimensions specified in 'dimension_numbers'.</p> <p>Associated contracting dimension numbers from the 'lhs' and 'rhs' do not need to be the same but must have the same dimension sizes.</p> <p>Example with contracting dimension numbers:</p> <pre><code>lhs = { {1.0, 2.0, 3.0},\n{4.0, 5.0, 6.0} }\n\nrhs = { {1.0, 1.0, 1.0},\n{2.0, 2.0, 2.0} }\n\nDotDimensionNumbers dnums;\ndnums.add_lhs_contracting_dimensions(1);\ndnums.add_rhs_contracting_dimensions(1);\n\nDotGeneral(lhs, rhs, dnums) -&gt; { {6.0, 12.0},\n{15.0, 30.0} }\n</code></pre> <p>Associated batch dimension numbers from the 'lhs' and 'rhs' must have the same dimension sizes.</p> <p>Example with batch dimension numbers (batch size 2, 2x2 matrices):</p> <pre><code>lhs = { { {1.0, 2.0},\n{3.0, 4.0} },\n{ {5.0, 6.0},\n{7.0, 8.0} } }\n\nrhs = { { {1.0, 0.0},\n{0.0, 1.0} },\n{ {1.0, 0.0},\n{0.0, 1.0} } }\n\nDotDimensionNumbers dnums;\ndnums.add_lhs_contracting_dimensions(2);\ndnums.add_rhs_contracting_dimensions(1);\ndnums.add_lhs_batch_dimensions(0);\ndnums.add_rhs_batch_dimensions(0);\n\nDotGeneral(lhs, rhs, dnums) -&gt; { { {1.0, 2.0},\n{3.0, 4.0} },\n{ {5.0, 6.0},\n{7.0, 8.0} } }\n</code></pre>    Input Output Semantics     [b0, m, k] <code>dot</code> [b0, k, n] [b0, m, n] batch matmul   [b0, b1, m, k] <code>dot</code> [b0, b1, k, n] [b0, b1, m, n] batch matmul    <p>It follows that the resulting dimension number starts with the batch dimension, then the 'lhs' non-contracting/non-batch dimension, and finally the 'rhs' non-contracting/non-batch dimension.</p>"},{"location":"operation_semantics/#dynamicslice","title":"DynamicSlice","text":"<p>See also <code>XlaBuilder::DynamicSlice</code>.</p> <p>DynamicSlice extracts a sub-array from the input array at dynamic <code>start_indices</code>. The size of the slice in each dimension is passed in <code>size_indices</code>, which specify the end point of exclusive slice intervals in each dimension: [start, start + size). The shape of <code>start_indices</code> must be rank == 1, with dimension size equal to the rank of <code>operand</code>.</p> <p> <code>DynamicSlice(operand, start_indices, size_indices)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> N dimensional array of type T   <code>start_indices</code> sequence of N <code>XlaOp</code> List of N scalar integers containing the starting indices of the slice for each dimension. Value must be greater than or equal to zero.   <code>size_indices</code> <code>ArraySlice&lt;int64&gt;</code> List of N integers containing the slice size for each dimension. Each value must be strictly greater than zero, and start + size must be less than or equal to the size of the dimension to avoid wrapping modulo dimension size.    <p>The effective slice indices are computed by applying the following transformation for each index <code>i</code> in <code>[1, N)</code> before performing the slice:</p> <pre><code>start_indices[i] = clamp(start_indices[i], 0, operand.dimension_size[i] - size_indices[i])\n</code></pre> <p>This ensures that the extracted slice is always in-bounds with respect to the operand array. If the slice is in-bounds before the transformation is applied, the transformation has no effect.</p> <p>1-dimensional example:</p> <pre><code>let a = {0.0, 1.0, 2.0, 3.0, 4.0}\nlet s = {2}\n\nDynamicSlice(a, s, {2}) produces:\n{2.0, 3.0}\n</code></pre> <p>2-dimensional example:</p> <pre><code>let b =\n{ {0.0,  1.0,  2.0},\n{3.0,  4.0,  5.0},\n{6.0,  7.0,  8.0},\n{9.0, 10.0, 11.0} }\nlet s = {2, 1}\n\nDynamicSlice(b, s, {2, 2}) produces:\n{ { 7.0,  8.0},\n{10.0, 11.0} }\n</code></pre>"},{"location":"operation_semantics/#dynamicupdateslice","title":"DynamicUpdateSlice","text":"<p>See also <code>XlaBuilder::DynamicUpdateSlice</code>.</p> <p>DynamicUpdateSlice generates a result which is the value of the input array <code>operand</code>, with a slice <code>update</code> overwritten at <code>start_indices</code>. The shape of <code>update</code> determines the shape of the sub-array of the result which is updated. The shape of <code>start_indices</code> must be rank == 1, with dimension size equal to the rank of <code>operand</code>.</p> <p> <code>DynamicUpdateSlice(operand, update, start_indices)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> N dimensional array of type T   <code>update</code> <code>XlaOp</code> N dimensional array of type T containing the slice update. Each dimension of update shape must be strictly greater than zero, and start + update must be less than or equal to the operand size for each dimension to avoid generating out-of-bounds update indices.   <code>start_indices</code> sequence of N <code>XlaOp</code> List of N scalar integers containing the starting indices of the slice for each dimension. Value must be greater than or equal to zero.    <p>The effective slice indices are computed by applying the following transformation for each index <code>i</code> in <code>[1, N)</code> before performing the slice:</p> <pre><code>start_indices[i] = clamp(start_indices[i], 0, operand.dimension_size[i] - update.dimension_size[i])\n</code></pre> <p>This ensures that the updated slice is always in-bounds with respect to the operand array. If the slice is in-bounds before the transformation is applied, the transformation has no effect.</p> <p>1-dimensional example:</p> <pre><code>let a = {0.0, 1.0, 2.0, 3.0, 4.0}\nlet u = {5.0, 6.0}\nlet s = {2}\n\nDynamicUpdateSlice(a, u, s) produces:\n{0.0, 1.0, 5.0, 6.0, 4.0}\n</code></pre> <p>2-dimensional example:</p> <pre><code>let b =\n{ {0.0,  1.0,  2.0},\n{3.0,  4.0,  5.0},\n{6.0,  7.0,  8.0},\n{9.0, 10.0, 11.0} }\nlet u =\n{ {12.0,  13.0},\n{14.0,  15.0},\n{16.0,  17.0} }\n\nlet s = {1, 1}\n\nDynamicUpdateSlice(b, u, s) produces:\n{ {0.0,  1.0,  2.0},\n{3.0, 12.0, 13.0},\n{6.0, 14.0, 15.0},\n{9.0, 16.0, 17.0} }\n</code></pre>"},{"location":"operation_semantics/#element-wise-binary-arithmetic-operations","title":"Element-wise binary arithmetic operations","text":"<p>See also <code>XlaBuilder::Add</code>.</p> <p>A set of element-wise binary arithmetic operations is supported.</p> <p> <code>Op(lhs, rhs)</code> </p> <p>Where <code>Op</code> is one of <code>Add</code> (addition), <code>Sub</code> (subtraction), <code>Mul</code> (multiplication), <code>Div</code> (division), <code>Rem</code> (remainder), <code>Max</code> (maximum), <code>Min</code> (minimum), <code>LogicalAnd</code> (logical AND), or <code>LogicalOr</code> (logical OR).</p>    Arguments Type Semantics     <code>lhs</code> <code>XlaOp</code> left-hand-side operand: array of type T   <code>rhs</code> <code>XlaOp</code> right-hand-side operand: array of type T    <p>The arguments' shapes have to be either similar or compatible. See the broadcasting documentation about what it means for shapes to be compatible. The result of an operation has a shape which is the result of broadcasting the two input arrays. In this variant, operations between arrays of different ranks are not supported, unless one of the operands is a scalar.</p> <p>When <code>Op</code> is <code>Rem</code>, the sign of the result is taken from the dividend, and the absolute value of the result is always less than the divisor's absolute value.</p> <p>Integer division overflow (signed/unsigned division/remainder by zero or signed division/remainder of <code>INT_SMIN</code> with <code>-1</code>) produces an implementation defined value.</p> <p>An alternative variant with different-rank broadcasting support exists for these operations:</p> <p> <code>Op(lhs, rhs, broadcast_dimensions)</code> </p> <p>Where <code>Op</code> is the same as above. This variant of the operation should be used for arithmetic operations between arrays of different ranks (such as adding a matrix to a vector).</p> <p>The additional <code>broadcast_dimensions</code> operand is a slice of integers used to expand the rank of the lower-rank operand up to the rank of the higher-rank operand. <code>broadcast_dimensions</code> maps the dimensions of the lower-rank shape to the dimensions of the higher-rank shape. The unmapped dimensions of the expanded shape are filled with dimensions of size one. Degenerate-dimension broadcasting then broadcasts the shapes along these degenerate dimensions to equalize the shapes of both operands. The semantics are described in detail on the broadcasting page.</p>"},{"location":"operation_semantics/#element-wise-comparison-operations","title":"Element-wise comparison operations","text":"<p>See also <code>XlaBuilder::Eq</code>.</p> <p>A set of standard element-wise binary comparison operations is supported. Note that standard IEEE 754 floating-point comparison semantics apply when comparing floating-point types.</p> <p> <code>Op(lhs, rhs)</code> </p> <p>Where <code>Op</code> is one of <code>Eq</code> (equal-to), <code>Ne</code> (not equal-to), <code>Ge</code> (greater-or-equal-than), <code>Gt</code> (greater-than), <code>Le</code> (less-or-equal-than), <code>Lt</code> (less-than). Another set of operators, EqTotalOrder, NeTotalOrder, GeTotalOrder, GtTotalOrder, LeTotalOrder, and LtTotalOrder, provide the same functionalities, except that they additionally support a total order over the floating point numbers, by enforcing -NaN &lt; -Inf &lt; -Finite &lt; -0 &lt; +0 &lt; +Finite &lt; +Inf &lt; +NaN.</p>    Arguments Type Semantics     <code>lhs</code> <code>XlaOp</code> left-hand-side operand: array of type T   <code>rhs</code> <code>XlaOp</code> right-hand-side operand: array of type T    <p>The arguments' shapes have to be either similar or compatible. See the broadcasting documentation about what it means for shapes to be compatible. The result of an operation has a shape which is the result of broadcasting the two input arrays with the element type <code>PRED</code>. In this variant, operations between arrays of different ranks are not supported, unless one of the operands is a scalar.</p> <p>An alternative variant with different-rank broadcasting support exists for these operations:</p> <p> <code>Op(lhs, rhs, broadcast_dimensions)</code> </p> <p>Where <code>Op</code> is the same as above. This variant of the operation should be used for comparison operations between arrays of different ranks (such as adding a matrix to a vector).</p> <p>The additional <code>broadcast_dimensions</code> operand is a slice of integers specifying the dimensions to use for broadcasting the operands. The semantics are described in detail on the broadcasting page.</p>"},{"location":"operation_semantics/#element-wise-unary-functions","title":"Element-wise unary functions","text":"<p>XlaBuilder supports these element-wise unary functions:</p> <p><code>Abs(operand)</code> Element-wise abs <code>x -&gt; |x|</code>.</p> <p><code>Ceil(operand)</code> Element-wise ceil <code>x -&gt; \u2308x\u2309</code>.</p> <p><code>Cos(operand)</code> Element-wise cosine <code>x -&gt; cos(x)</code>.</p> <p><code>Exp(operand)</code> Element-wise natural exponential <code>x -&gt; e^x</code>.</p> <p><code>Floor(operand)</code> Element-wise floor <code>x -&gt; \u230ax\u230b</code>.</p> <p><code>Imag(operand)</code> Element-wise imaginary part of a complex (or real) shape. <code>x -&gt; imag(x)</code>. If the operand is a floating point type, returns 0.</p> <p><code>IsFinite(operand)</code> Tests whether each element of <code>operand</code> is finite, i.e., is not positive or negative infinity, and is not <code>NaN</code>. Returns an array of <code>PRED</code> values with the same shape as the input, where each element is <code>true</code> if and only if the corresponding input element is finite.</p> <p><code>Log(operand)</code> Element-wise natural logarithm <code>x -&gt; ln(x)</code>.</p> <p><code>LogicalNot(operand)</code> Element-wise logical not <code>x -&gt; !(x)</code>.</p> <p><code>Logistic(operand)</code> Element-wise logistic function computation <code>x -&gt; logistic(x)</code>.</p> <p><code>PopulationCount(operand)</code> Computes the number of bits set in each element of <code>operand</code>.</p> <p><code>Neg(operand)</code> Element-wise negation <code>x -&gt; -x</code>.</p> <p><code>Real(operand)</code> Element-wise real part of a complex (or real) shape. <code>x -&gt; real(x)</code>. If the operand is a floating point type, returns the same value.</p> <p><code>Rsqrt(operand)</code> Element-wise reciprocal of square root operation <code>x -&gt; 1.0 / sqrt(x)</code>.</p> <p><code>Sign(operand)</code> Element-wise sign operation <code>x -&gt; sgn(x)</code> where</p> \\[\\text{sgn}(x) = \\begin{cases} -1 &amp; x &lt; 0\\\\ -0 &amp; x = -0\\\\ NaN &amp; x = NaN\\\\ +0 &amp; x = +0\\\\ 1 &amp; x &gt; 0 \\end{cases}\\] <p>using the comparison operator of the element type of <code>operand</code>.</p> <p><code>Sqrt(operand)</code> Element-wise square root operation <code>x -&gt; sqrt(x)</code>.</p> <p><code>Cbrt(operand)</code> Element-wise cubic root operation <code>x -&gt; cbrt(x)</code>.</p> <p><code>Tanh(operand)</code> Element-wise hyperbolic tangent <code>x -&gt; tanh(x)</code>.</p> <p><code>Round(operand)</code> Element-wise rounding, ties away from zero.</p> <p><code>RoundNearestEven(operand)</code> Element-wise rounding, ties to nearest even.</p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The operand to the function    <p>The function is applied to each element in the <code>operand</code> array, resulting in an array with the same shape. It is allowed for <code>operand</code> to be a scalar (rank 0).</p>"},{"location":"operation_semantics/#fft","title":"Fft","text":"<p>The XLA FFT operation implements the forward and inverse Fourier Transforms for real and complex inputs/outputs. Multidimensional FFTs on up to 3 axes are supported.</p> <p>See also <code>XlaBuilder::Fft</code>.</p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The array we are Fourier transforming.   <code>fft_type</code> <code>FftType</code> See the table below.   <code>fft_length</code> <code>ArraySlice&lt;int64&gt;</code> The time-domain lengths of the axes being transformed. This is needed in particular for IRFFT to right-size the innermost axis, since <code>RFFT(fft_length=[16])</code> has the same output shape as <code>RFFT(fft_length=[17])</code>.       <code>FftType</code> Semantics     <code>FFT</code> Forward complex-to-complex FFT. Shape is unchanged.   <code>IFFT</code> Inverse complex-to-complex FFT. Shape is unchanged.   <code>RFFT</code> Forward real-to-complex FFT. Shape of the innermost axis is reduced to <code>fft_length[-1] // 2 + 1</code> if <code>fft_length[-1]</code> is a non-zero value, omitting the reversed conjugate part of the transformed signal beyond the Nyquist frequency.   <code>IRFFT</code> Inverse real-to-complex FFT (i.e. takes complex, returns real). Shape of the innermost axis is expanded to <code>fft_length[-1]</code> if <code>fft_length[-1]</code> is a non-zero value, inferring the part of the transformed signal beyond the Nyquist frequency from the reverse conjugate of the <code>1</code> to <code>fft_length[-1] // 2 + 1</code> entries."},{"location":"operation_semantics/#multidimensional-fft","title":"Multidimensional FFT","text":"<p>When more than 1 <code>fft_length</code> is provided, this is equivalent to applying a cascade of FFT operations to each of the innermost axes. Note that for the real-&gt;complex and complex-&gt;real cases, the innermost axis transform is (effectively) performed first (RFFT; last for IRFFT), which is why the innermost axis is the one which changes size. Other axis transforms will then be complex-&gt;complex.</p>"},{"location":"operation_semantics/#implementation-details","title":"Implementation details","text":"<p>CPU FFT is backed by Eigen's TensorFFT. GPU FFT uses cuFFT.</p>"},{"location":"operation_semantics/#gather","title":"Gather","text":"<p>The XLA gather operation stitches together several slices (each slice at a potentially different runtime offset) of an input array.</p>"},{"location":"operation_semantics/#general-semantics","title":"General Semantics","text":"<p>See also <code>XlaBuilder::Gather</code>. For a more intuitive description, see the \"Informal Description\" section below.</p> <p> <code>gather(operand, start_indices, offset_dims, collapsed_slice_dims, slice_sizes, start_index_map)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The array we\u2019re gathering from.   <code>start_indices</code> <code>XlaOp</code> Array containing the starting indices of the slices we gather.   <code>index_vector_dim</code> <code>int64</code> The dimension in <code>start_indices</code> that \"contains\" the starting indices. See below for a detailed description.   <code>offset_dims</code> <code>ArraySlice&lt;int64&gt;</code> The set of dimensions in the output shape that offset into an array sliced from operand.   <code>slice_sizes</code> <code>ArraySlice&lt;int64&gt;</code> <code>slice_sizes[i]</code> is the bounds for the slice on dimension <code>i</code>.   <code>collapsed_slice_dims</code> <code>ArraySlice&lt;int64&gt;</code> The set of dimensions in each slice that are collapsed away. These dimensions must have size 1.   <code>start_index_map</code> <code>ArraySlice&lt;int64&gt;</code> A map that describes how to map indices in <code>start_indices</code> to legal indices into operand.   <code>indices_are_sorted</code> <code>bool</code> Whether the indices are guaranteed to be sorted by the caller.   <code>unique_indices</code> <code>bool</code> Whether the indices are guaranteed to be unique by the caller.    <p>For convenience, we label dimensions in the output array not in <code>offset_dims</code> as <code>batch_dims</code>.</p> <p>The output is an array of rank <code>batch_dims.size</code> + <code>offset_dims.size</code>.</p> <p>The <code>operand.rank</code> must equal the sum of <code>offset_dims.size</code> and <code>collapsed_slice_dims.size</code>. Also, <code>slice_sizes.size</code> has to be equal to <code>operand.rank</code>.</p> <p>If <code>index_vector_dim</code> is equal to <code>start_indices.rank</code> we implicitly consider <code>start_indices</code> to have a trailing <code>1</code> dimension (i.e. if <code>start_indices</code> was of shape <code>[6,7]</code> and <code>index_vector_dim</code> is <code>2</code> then we implicitly consider the shape of <code>start_indices</code> to be <code>[6,7,1]</code>).</p> <p>The bounds for the output array along dimension <code>i</code> is computed as follows:</p> <ol> <li> <p>If <code>i</code> is present in <code>batch_dims</code> (i.e. is equal to <code>batch_dims[k]</code> for some <code>k</code>) then we pick the corresponding dimension bounds out of <code>start_indices.shape</code>, skipping <code>index_vector_dim</code> (i.e. pick <code>start_indices.shape.dims</code>[<code>k</code>] if <code>k</code> &lt; <code>index_vector_dim</code> and <code>start_indices.shape.dims</code>[<code>k</code>+<code>1</code>] otherwise).</p> </li> <li> <p>If <code>i</code> is present in <code>offset_dims</code> (i.e. equal to <code>offset_dims</code>[<code>k</code>] for some <code>k</code>) then we pick the corresponding bound out of <code>slice_sizes</code> after accounting for <code>collapsed_slice_dims</code> (i.e. we pick <code>adjusted_slice_sizes</code>[<code>k</code>] where <code>adjusted_slice_sizes</code> is <code>slice_sizes</code> with the bounds at indices <code>collapsed_slice_dims</code> removed).</p> </li> </ol> <p>Formally, the operand index <code>In</code> corresponding to a given output index <code>Out</code> is calculated as follows:</p> <ol> <li> <p>Let <code>G</code> = { <code>Out</code>[<code>k</code>] for <code>k</code> in <code>batch_dims</code> }. Use <code>G</code> to slice out a     vector <code>S</code> such that <code>S</code>[<code>i</code>] = <code>start_indices</code>[Combine(<code>G</code>, <code>i</code>)] where     Combine(A, b) inserts b at position <code>index_vector_dim</code> into A. Note that     this is well defined even if <code>G</code> is empty -- if <code>G</code> is empty then <code>S</code> =     <code>start_indices</code>.</p> </li> <li> <p>Create a starting index, <code>S</code><code>in</code>, into <code>operand</code> using <code>S</code> by     scattering <code>S</code> using <code>start_index_map</code>. More precisely:</p> <ol> <li> <p><code>S</code><code>in</code>[<code>start_index_map</code>[<code>k</code>]] = <code>S</code>[<code>k</code>] if <code>k</code> &lt;     <code>start_index_map.size</code>.</p> </li> <li> <p><code>S</code><code>in</code>[<code>_</code>] = <code>0</code> otherwise.</p> </li> </ol> </li> <li> <p>Create an index <code>O</code><code>in</code> into <code>operand</code> by scattering the indices     at the offset dimensions in <code>Out</code> according to the <code>collapsed_slice_dims</code>     set. More precisely:</p> <ol> <li> <p><code>O</code><code>in</code>[<code>remapped_offset_dims</code>(<code>k</code>)] =     <code>Out</code>[<code>offset_dims</code>[<code>k</code>]] if <code>k</code> &lt; <code>offset_dims.size</code>     (<code>remapped_offset_dims</code> is defined below).</p> </li> <li> <p><code>O</code><code>in</code>[<code>_</code>] = <code>0</code> otherwise.</p> </li> </ol> </li> <li> <p><code>In</code> is <code>O</code><code>in</code> + <code>S</code><code>in</code> where + is element-wise     addition.</p> </li> </ol> <p><code>remapped_offset_dims</code> is a monotonic function with domain [<code>0</code>, <code>offset_dims.size</code>) and range [<code>0</code>, <code>operand.rank</code>) \\ <code>collapsed_slice_dims</code>. So if, e.g., <code>offset_dims.size</code> is <code>4</code>, <code>operand.rank</code> is <code>6</code> and <code>collapsed_slice_dims</code> is {<code>0</code>, <code>2</code>} then <code>remapped_offset_dims</code> is {<code>0</code>\u2192<code>1</code>, <code>1</code>\u2192<code>3</code>, <code>2</code>\u2192<code>4</code>, <code>3</code>\u2192<code>5</code>}.</p> <p>If <code>indices_are_sorted</code> is set to true then XLA can assume that <code>start_indices</code> are sorted (in ascending <code>start_index_map</code> order) by the user. If they are not then the semantics is implementation defined.</p> <p>If <code>unique_indices</code> is set to true then XLA can assume that all element scattered to are unique. So XLA could use non-atomic operations. If <code>unique_indices</code> is set to true and the indices being scattered to are not unique then the semantics is implementation defined.</p>"},{"location":"operation_semantics/#informal-description-and-examples","title":"Informal Description and Examples","text":"<p>Informally, every index <code>Out</code> in the output array corresponds to an element <code>E</code> in the operand array, computed as follows:</p> <ul> <li> <p>We use the batch dimensions in <code>Out</code> to look up a starting index from     <code>start_indices</code>.</p> </li> <li> <p>We use <code>start_index_map</code> to map the starting index (whose size may be less     than operand.rank) to a \"full\" starting index into the <code>operand</code>.</p> </li> <li> <p>We dynamic-slice out a slice with size <code>slice_sizes</code> using the full starting     index.</p> </li> <li> <p>We reshape the slice by collapsing the <code>collapsed_slice_dims</code> dimensions.     Since all collapsed slice dimensions must have a bound of 1, this reshape is     always legal.</p> </li> <li> <p>We use the offset dimensions in <code>Out</code> to index into this slice to get the     input element, <code>E</code>, corresponding to output index <code>Out</code>.</p> </li> </ul> <p><code>index_vector_dim</code> is set to <code>start_indices.rank</code> - <code>1</code> in all of the examples that follow. More interesting values for <code>index_vector_dim</code> do not change the operation fundamentally, but make the visual representation more cumbersome.</p> <p>To get an intuition on how all of the above fits together, let's look at an example that gathers 5 slices of shape <code>[8,6]</code> from a <code>[16,11]</code> array.  The position of a slice into the <code>[16,11]</code> array can be represented as an index vector of shape <code>S64[2]</code>, so the set of 5 positions can be represented as a <code>S64[5,2]</code> array.</p> <p>The behavior of the gather operation can then be depicted as an index transformation that takes [<code>G</code>,<code>O</code><code>0</code>,<code>O</code><code>1</code>], an index in the output shape, and maps it to an element in the input array in the following way:</p>  <p>We first select an (<code>X</code>,<code>Y</code>) vector from the gather indices array using <code>G</code>. The element in the output array at index [<code>G</code>,<code>O</code><code>0</code>,<code>O</code><code>1</code>] is then the element in the input array at index [<code>X</code>+<code>O</code><code>0</code>,<code>Y</code>+<code>O</code><code>1</code>].</p> <p><code>slice_sizes</code> is <code>[8,6]</code>, which decides the range of O<code>0</code> and O<code>1</code>, and this in turn decides the bounds of the slice.</p> <p>This gather operation acts as a batch dynamic slice with <code>G</code> as the batch dimension.</p> <p>The gather indices may be multidimensional.  For instance, a more general version of the example above using a \"gather indices\" array of shape <code>[4,5,2]</code> would translate indices like this:</p>  <p>Again, this acts as a batch dynamic slice <code>G</code><code>0</code> and <code>G</code><code>1</code> as the batch dimensions.  The slice size is still <code>[8,6]</code>.</p> <p>The gather operation in XLA generalizes the informal semantics outlined above in the following ways:</p> <ol> <li> <p>We can configure which dimensions in the output shape are the offset dimensions (dimensions containing <code>O</code><code>0</code>, <code>O</code><code>1</code> in the last example).  The output batch dimensions (dimensions containing <code>G</code><code>0</code>, <code>G</code><code>1</code> in the last example) are defined to be the output dimensions that are not offset dimensions.</p> </li> <li> <p>The number of output offset dimensions explicitly present in the output shape may be smaller than the input rank.  These \"missing\" dimensions, which are listed explicitly as <code>collapsed_slice_dims</code>, must have a slice size of <code>1</code>.  Since they have a slice size of <code>1</code> the only valid index for them is <code>0</code> and eliding them does not introduce ambiguity.</p> </li> <li> <p>The slice extracted from the \"Gather Indices\" array ((<code>X</code>, <code>Y</code>) in the last example) may have fewer elements than the input array rank, and an explicit mapping dictates how the index should be expanded to have the same rank as the input.</p> </li> </ol> <p>As a final example, we use (2) and (3) to implement <code>tf.gather_nd</code>:</p>  <p><code>G</code><code>0</code> and <code>G</code><code>1</code> are used to slice out a starting index from the gather indices array as usual, except the starting index has only one element, <code>X</code>. Similarly, there is only one output offset index with the value <code>O</code><code>0</code>. However, before being used as indices into the input array, these are expanded in accordance to \"Gather Index Mapping\" (<code>start_index_map</code> in the formal description) and \"Offset Mapping\" (<code>remapped_offset_dims</code> in the formal description) into [<code>X</code>,<code>0</code>] and [<code>0</code>,<code>O</code><code>0</code>] respectively, adding up to [<code>X</code>,<code>O</code><code>0</code>]. In other words, the output index [<code>G</code><code>0</code>,<code>G</code><code>1</code>,<code>O</code><code>0</code>] maps to the input index [<code>GatherIndices</code>[<code>G</code><code>0</code>,<code>G</code><code>1</code>,<code>0</code>],<code>O</code><code>0</code>] which gives us the semantics for <code>tf.gather_nd</code>.</p> <p><code>slice_sizes</code> for this case is <code>[1,11]</code>.  Intuitively this means that every index <code>X</code> in the gather indices array picks an entire row and the result is the concatenation of all these rows.</p>"},{"location":"operation_semantics/#getdimensionsize","title":"GetDimensionSize","text":"<p>See also <code>XlaBuilder::GetDimensionSize</code>.</p> <p>Returns the size of the given dimension of the operand. The operand must be array shaped.</p> <p> <code>GetDimensionSize(operand, dimension)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional input array   <code>dimension</code> <code>int64</code> A value in the interval <code>[0, n)</code> that specifies the dimension"},{"location":"operation_semantics/#setdimensionsize","title":"SetDimensionSize","text":"<p>See also <code>XlaBuilder::SetDimensionSize</code>.</p> <p>Sets the dynamic size of XlaOp's given dimension. The operand must be array shaped.</p> <p> <code>SetDimensionSize(operand, size, dimension)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> n dimensional input array.   <code>size</code> <code>XlaOp</code> int32 representing the runtime dynamic size.   <code>dimension</code> <code>int64</code> A value in the interval <code>[0, n)</code> that specifies the dimension.    <p>Pass through the operand as result, with dynamic dimension tracked by the compiler.</p> <p>Padded values will be ignored by downstream reduction ops.</p> <pre><code>let v: f32[10] = f32[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nlet five: s32 = 5;\nlet six: s32 = 6;\n\n// Setting dynamic dimension size doesn't change the upper bound of the static\n// shape.\nlet padded_v_five: f32[10] = set_dimension_size(v, five, /*dimension=*/0);\nlet padded_v_six: f32[10] = set_dimension_size(v, six, /*dimension=*/0);\n\n// sum == 1 + 2 + 3 + 4 + 5\nlet sum:f32[] = reduce_sum(padded_v_five);\n// product == 1 * 2 * 3 * 4 * 5\nlet product:f32[] = reduce_product(padded_v_five);\n\n// Changing padding size will yield different result.\n// sum == 1 + 2 + 3 + 4 + 5 + 6\nlet sum:f32[] = reduce_sum(padded_v_six);\n</code></pre>"},{"location":"operation_semantics/#gettupleelement","title":"GetTupleElement","text":"<p>See also <code>XlaBuilder::GetTupleElement</code>.</p> <p>Indexes into a tuple with a compile-time-constant value.</p> <p>The value must be a compile-time-constant so that shape inference can determine the type of the resulting value.</p> <p>This is analogous to <code>std::get&lt;int N&gt;(t)</code> in C++. Conceptually:</p> <pre><code>let v: f32[10] = f32[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nlet s: s32 = 5;\nlet t: (f32[10], s32) = tuple(v, s);\nlet element_1: s32 = gettupleelement(t, 1);  // Inferred shape matches s32.\n</code></pre> <p>See also <code>tf.tuple</code>.</p>"},{"location":"operation_semantics/#infeed","title":"Infeed","text":"<p>See also <code>XlaBuilder::Infeed</code>.</p> <p> <code>Infeed(shape)</code> </p>    Argument Type Semantics     <code>shape</code> <code>Shape</code> Shape of the data read from the Infeed interface. The layout field of the shape must be set to match the layout of the data sent to the device; otherwise its behavior is undefined.    <p>Reads a single data item from the implicit Infeed streaming interface of the device, interpreting the data as the given shape and its layout, and returns a <code>XlaOp</code> of the data. Multiple Infeed operations are allowed in a computation, but there must be a total order among the Infeed operations. For example, two Infeeds in the code below have a total order since there is a dependency between the while loops.</p> <pre><code>result1 = while (condition, init = init_value) {\n  Infeed(shape)\n}\n\nresult2 = while (condition, init = result1) {\n  Infeed(shape)\n}\n</code></pre> <p>Nested tuple shapes are not supported. For an empty tuple shape, the Infeed operation is effectively a no-op and proceeds without reading any data from the Infeed of the device.</p>  <p>Note: We plan to allow multiple Infeed operations without a total order, in which case the compiler will provide information about how the Infeed operations are serialized in the compiled program.</p>"},{"location":"operation_semantics/#iota","title":"Iota","text":"<p>See also <code>XlaBuilder::Iota</code>.</p> <p> <code>Iota(shape, iota_dimension)</code> </p> <p>Builds a constant literal on device rather than a potentially large host transfer. Creates an array that has specified shape and holds values starting at zero and incrementing by one along the specified dimension. For floating-point types, the produced array is equivalent to <code>ConvertElementType(Iota(...))</code> where the <code>Iota</code> is of integral type and the conversion is to the floating-point type.</p>    Arguments Type Semantics     <code>shape</code> <code>Shape</code> Shape of the array created by <code>Iota()</code>   <code>iota_dimension</code> <code>int64</code> The dimension to increment along.    <p>For example, <code>Iota(s32[4, 8], 0)</code> returns</p> <pre><code>  [[0, 0, 0, 0, 0, 0, 0, 0 ],\n   [1, 1, 1, 1, 1, 1, 1, 1 ],\n   [2, 2, 2, 2, 2, 2, 2, 2 ],\n   [3, 3, 3, 3, 3, 3, 3, 3 ]]\n</code></pre> <p><code>Iota(s32[4, 8], 1)</code> returns</p> <pre><code>  [[0, 1, 2, 3, 4, 5, 6, 7 ],\n   [0, 1, 2, 3, 4, 5, 6, 7 ],\n   [0, 1, 2, 3, 4, 5, 6, 7 ],\n   [0, 1, 2, 3, 4, 5, 6, 7 ]]\n</code></pre>"},{"location":"operation_semantics/#map","title":"Map","text":"<p>See also <code>XlaBuilder::Map</code>.</p> <p> <code>Map(operands..., computation)</code> </p>    Arguments Type Semantics     <code>operands</code> sequence of N <code>XlaOp</code>s N arrays of types T_0..T_{N-1}   <code>computation</code> <code>XlaComputation</code> computation of type <code>T_0, T_1, .., T_{N + M -1} -&gt; S</code> with N parameters of type T and M of arbitrary type   <code>dimensions</code> <code>int64</code> array array of map dimensions    <p>Applies a scalar function over the given <code>operands</code> arrays, producing an array of the same dimensions where each element is the result of the mapped function applied to the corresponding elements in the input arrays.</p> <p>The mapped function is an arbitrary computation with the restriction that it has N inputs of scalar type <code>T</code> and a single output with type <code>S</code>. The output has the same dimensions as the operands except that the element type T is replaced with S.</p> <p>For example: <code>Map(op1, op2, op3, computation, par1)</code> maps <code>elem_out &lt;- computation(elem1, elem2, elem3, par1)</code> at each (multi-dimensional) index in the input arrays to produce the output array.</p>"},{"location":"operation_semantics/#optimizationbarrier","title":"OptimizationBarrier","text":"<p>Blocks any optimization pass from moving computations across the barrier.</p> <p>Ensures that all inputs are evaluated before any operators that depend on the barrier's outputs.</p>"},{"location":"operation_semantics/#pad","title":"Pad","text":"<p>See also <code>XlaBuilder::Pad</code>.</p> <p> <code>Pad(operand, padding_value, padding_config)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type <code>T</code>   <code>padding_value</code> <code>XlaOp</code> scalar of type <code>T</code> to fill in the added padding   <code>padding_config</code> <code>PaddingConfig</code> padding amount on both edges (low, high) and between the elements of each dimension    <p>Expands the given <code>operand</code> array by padding around the array as well as between the elements of the array with the given <code>padding_value</code>. <code>padding_config</code> specifies the amount of edge padding and the interior padding for each dimension.</p> <p><code>PaddingConfig</code> is a repeated field of <code>PaddingConfigDimension</code>, which contains three fields for each dimension: <code>edge_padding_low</code>, <code>edge_padding_high</code>, and <code>interior_padding</code>.</p> <p><code>edge_padding_low</code> and <code>edge_padding_high</code> specify the amount of padding added at the low-end (next to index 0) and the high-end (next to the highest index) of each dimension respectively. The amount of edge padding can be negative -- the absolute value of negative padding indicates the number of elements to remove from the specified dimension.</p> <p><code>interior_padding</code> specifies the amount of padding added between any two elements in each dimension; it may not be negative.  Interior padding occurs logically before edge padding, so in the case of negative edge padding, elements are removed from the interior-padded operand.</p> <p>This operation is a no-op if the edge padding pairs are all (0, 0) and the interior padding values are all 0. The figure below shows examples of different <code>edge_padding</code> and <code>interior_padding</code> values for a two-dimensional array.</p>"},{"location":"operation_semantics/#recv","title":"Recv","text":"<p>See also <code>XlaBuilder::Recv</code>.</p> <p> <code>Recv(shape, channel_handle)</code> </p>    Arguments Type Semantics     <code>shape</code> <code>Shape</code> shape of the data to receive   <code>channel_handle</code> <code>ChannelHandle</code> unique identifier for each send/recv pair    <p>Receives data of the given shape from a <code>Send</code> instruction in another computation that shares the same channel handle. Returns a XlaOp for the received data.</p> <p>The client API of <code>Recv</code> operation represents synchronous communication. However, the instruction is internally decomposed into 2 HLO instructions (<code>Recv</code> and <code>RecvDone</code>) to enable asynchronous data transfers. See also <code>HloInstruction::CreateRecv</code> and <code>HloInstruction::CreateRecvDone</code>.</p> <p><code>Recv(const Shape&amp; shape, int64 channel_id)</code></p> <p>Allocates resources required to receive data from a <code>Send</code> instruction with the same channel_id. Returns a context for the allocated resources, which is used by a following <code>RecvDone</code> instruction to wait for the completion of the data transfer. The context is a tuple of {receive buffer (shape), request identifier (U32)} and it can only be used by a <code>RecvDone</code> instruction.</p> <p> <code>RecvDone(HloInstruction context)</code> </p> <p>Given a context created by a <code>Recv</code> instruction, waits for the data transfer to complete and returns the received data.</p>"},{"location":"operation_semantics/#reduce","title":"Reduce","text":"<p>See also <code>XlaBuilder::Reduce</code>.</p> <p>Applies a reduction function to one or more arrays in parallel.</p> <p> <code>Reduce(operands..., init_values..., computation, dimensions)</code> </p>    Arguments Type Semantics     <code>operands</code> Sequence of N <code>XlaOp</code> N arrays of types <code>T_0, ..., T_{N-1}</code>.   <code>init_values</code> Sequence of N <code>XlaOp</code> N scalars of types <code>T_0, ..., T_{N-1}</code>.   <code>computation</code> <code>XlaComputation</code> computation of type <code>T_0, ..., T_{N-1}, T_0, ..., T_{N-1} -&gt;</code> <code>Collate(T_0, ..., T_{N-1})</code>.   <code>dimensions</code> <code>int64</code> array unordered array of dimensions to reduce.    <p>Where:</p> <ul> <li>N is required to be greater or equal to 1.</li> <li>The computation has to be \"roughly\" associative (see below).</li> <li>All input arrays must have the same dimensions.</li> <li>All initial values have to form an identity under <code>computation</code>.</li> <li>If <code>N = 1</code>, <code>Collate(T)</code> is <code>T</code>.</li> <li>If <code>N &gt; 1</code>, <code>Collate(T_0, ..., T_{N-1})</code> is a tuple of <code>N</code> elements of type     <code>T</code>.</li> </ul> <p>This operation reduces one or more dimensions of each input array into scalars. The rank of each returned array is <code>rank(operand) - len(dimensions)</code>. The output of the op is <code>Collate(Q_0, ..., Q_N)</code> where <code>Q_i</code> is an array of type <code>T_i</code>, the dimensions of which are described below.</p> <p>Different backends are allowed to reassociate the reduction computation.  This can lead to numerical differences, as some reduction functions like addition are not associative for floats. However, if the range of the data is limited, floating-point addition is close enough to being associative for most practical uses.</p>"},{"location":"operation_semantics/#examples","title":"Examples","text":"<p>When reducing across one dimension in a single 1D array with values <code>[10, 11, 12, 13]</code>, with reduction function <code>f</code> (this is <code>computation</code>) then that could be computed as</p> <p><code>f(10, f(11, f(12, f(init_value, 13)))</code></p> <p>but there are also many other possibilities, e.g.</p> <p><code>f(init_value, f(f(10, f(init_value, 11)), f(f(init_value, 12), f(init_value, 13))))</code></p> <p>The following is a rough pseudo-code example of how reduction could be implemented, using summation as the reduction computation with an initial value of 0.</p> <pre><code>result_shape &lt;- remove all dims in dimensions from operand_shape\n\n# Iterate over all elements in result_shape. The number of r's here is equal\n# to the rank of the result\nfor r0 in range(result_shape[0]), r1 in range(result_shape[1]), ...:\n  # Initialize this result element\n  result[r0, r1...] &lt;- 0\n\n  # Iterate over all the reduction dimensions\n  for d0 in range(dimensions[0]), d1 in range(dimensions[1]), ...:\n    # Increment the result element with the value of the operand's element.\n    # The index of the operand's element is constructed from all ri's and di's\n    # in the right order (by construction ri's and di's together index over the\n    # whole operand shape).\n    result[r0, r1...] += operand[ri... di]\n</code></pre> <p>Here's an example of reducing a 2D array (matrix). The shape has rank 2, dimension 0 of size 2 and dimension 1 of size 3:</p>  <p>Results of reducing dimensions 0 or 1 with an \"add\" function:</p>  <p>Note that both reduction results are 1D arrays. The diagram shows one as column and another as row just for visual convenience.</p> <p>For a more complex example, here is a 3D array. Its rank is 3, dimension 0 of size 4, dimension 1 of size 2 and dimension 2 of size 3. For simplicity, the values 1 to 6 are replicated across dimension 0.</p>  <p>Similarly to the 2D example, we can reduce just one dimension. If we reduce dimension 0, for example, we get a rank-2 array where all values across dimension 0 were folded into a scalar:</p> <pre><code>|  4   8  12 |\n| 16  20  24 |\n</code></pre> <p>If we reduce dimension 2, we also get a rank-2 array where all values across dimension 2 were folded into a scalar:</p> <pre><code>| 6  15 |\n| 6  15 |\n| 6  15 |\n| 6  15 |\n</code></pre> <p>Note that the relative order between the remaining dimensions in the input is preserved in the output, but some dimensions may get assigned new numbers (since the rank changes).</p> <p>We can also reduce multiple dimensions. Add-reducing dimensions 0 and 1 produces the 1D array <code>[20, 28, 36]</code>.</p> <p>Reducing the 3D array over all its dimensions produces the scalar <code>84</code>.</p>"},{"location":"operation_semantics/#variadic-reduce","title":"Variadic Reduce","text":"<p>When <code>N &gt; 1</code>, reduce function application is slightly more complex, as it is applied simultaneously to all inputs. The operands are supplied to the computation in the following order:</p> <ul> <li>Running reduced value for the first operand</li> <li>...</li> <li>Running reduced value for the N'th operand</li> <li>Input value for the first operand</li> <li>...</li> <li>Input value for the N'th operand</li> </ul> <p>For example, consider the following reduction function, which can be used to compute the max and the argmax of a 1-D array in parallel:</p> <pre><code>f: (Float, Int, Float, Int) -&gt; Float, Int\nf(max, argmax, value, index):\n  if value &gt;= max:\n    return (value, index)\n  else:\n    return (max, argmax)\n</code></pre> <p>For 1-D Input arrays <code>V = Float[N], K = Int[N]</code>, and init values <code>I_V = Float, I_K =  Int</code>, the result <code>f_(N-1)</code> of reducing across the only input dimension is equivalent to the following recursive application:</p> <pre><code>f_0 = f(I_V, I_K, V_0, K_0)\nf_1 = f(f_0.first, f_0.second, V_1, K_1)\n...\nf_(N-1) = f(f_(N-2).first, f_(N-2).second, V_(N-1), K_(N-1))\n</code></pre> <p>Applying this reduction to an array of values, and an array of sequential indices (i.e. iota), will co-iterate over the arrays, and return a tuple containing the maximal value and the matching index.</p>"},{"location":"operation_semantics/#reduceprecision","title":"ReducePrecision","text":"<p>See also <code>XlaBuilder::ReducePrecision</code>.</p> <p>Models the effect of converting floating-point values to a lower-precision format (such as IEEE-FP16) and back to the original format.  The number of exponent and mantissa bits in the lower-precision format can be specified arbitrarily, although all bit sizes may not be supported on all hardware implementations.</p> <p> <code>ReducePrecision(operand, mantissa_bits, exponent_bits)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of floating-point type <code>T</code>.   <code>exponent_bits</code> <code>int32</code> number of exponent bits in lower-precision format   <code>mantissa_bits</code> <code>int32</code> number of mantissa bits in lower-precision format    <p>The result is an array of type <code>T</code>.  The input values are rounded to the nearest value representable with the given number of mantissa bits (using \"ties to even\" semantics), and any values that exceed the range specified by the number of exponent bits are clamped to positive or negative infinity.  <code>NaN</code> values are retained, although they may be converted to canonical <code>NaN</code> values.</p> <p>The lower-precision format must have at least one exponent bit (in order to distinguish a zero value from an infinity, since both have a zero mantissa), and must have a non-negative number of mantissa bits.  The number of exponent or mantissa bits may exceed the corresponding value for type <code>T</code>; the corresponding portion of the conversion is then simply a no-op.</p>"},{"location":"operation_semantics/#reducescatter","title":"ReduceScatter","text":"<p>See also <code>XlaBuilder::ReduceScatter</code>.</p> <p>ReduceScatter is a collective operation that effectively does an AllReduce and then scatters the result by splitting it into <code>shard_count</code> blocks along the <code>scatter_dimension</code> and replica <code>i</code> in the replica group receives the <code>ith</code> shard.</p> <p> <code>ReduceScatter(operand, computation, scatter_dim, shard_count, replica_group_ids, channel_id)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> Array or a non-empty tuple of arrays to reduce across replicas.   <code>computation</code> <code>XlaComputation</code> Reduction computation   <code>scatter_dimension</code> <code>int64</code> Dimension to scatter.   <code>shard_count</code> <code>int64</code> Number of blocks to split <code>scatter_dimension</code>   <code>replica_groups</code> vector of vectors of  <code>int64</code> Groups between which the reductions are performed   <code>channel_id</code> optional <code>int64</code> Optional channel ID for cross-module communication    <ul> <li>When <code>operand</code> is a tuple of arrays, the reduce-scatter is performed on each     element of the tuple.</li> <li><code>replica_groups</code> is a list of replica groups between which the reduction is     performed (replica id for the current replica can be retrieved using     <code>ReplicaId</code>). The order of replicas in each group determines     the order in which the all-reduce result will be scattered. <code>replica_groups</code>     must either be empty (in which case all replicas belong to a single group),     or contain the same number of elements as the number of replicas. When there     are more than one replica groups, they all must be of the same size. For     example, <code>replica_groups = {0, 2}, {1, 3}</code> performs reduction between the     replicas <code>0</code> and <code>2</code>, and <code>1</code> and <code>3</code> and then scatters the result.</li> <li><code>shard_count</code> is the size of each replica group. We need this in cases where     <code>replica_groups</code> are empty. If <code>replica_groups</code> is not empty, <code>shard_count</code>     must be equal to the size of each replica group.</li> <li><code>channel_id</code> is used for cross-module communication: only <code>reduce-scatter</code>     operations with the same <code>channel_id</code> can communicate with each other.</li> </ul> <p>The output shape is the input shape with the <code>scatter_dimension</code> made <code>shard_count</code> times smaller. For example, if there are two replicas and the operand has the value <code>[1.0, 2.25]</code> and <code>[3.0, 5.25]</code> respectively on the two replicas, then the output value from this op where <code>scatter_dim</code> is <code>0</code> will be <code>[4.0]</code> for the first replica and <code>[7.5]</code> for the second replica.</p>"},{"location":"operation_semantics/#reducewindow","title":"ReduceWindow","text":"<p>See also <code>XlaBuilder::ReduceWindow</code>.</p> <p>Applies a reduction function to all elements in each window of a sequence of N multi-dimensional arrays, producing a single or a tuple of N multi-dimensional arrays as output. Each output array has the same number of elements as the number of valid positions of the window. A pooling layer can be expressed as a <code>ReduceWindow</code>. Similar to <code>Reduce</code>, the applied <code>computation</code> is always passed the <code>init_values</code> on the left-hand side.</p> <p> <code>ReduceWindow(operands..., init_values..., computation, window_dimensions, window_strides, padding)</code> </p>    Arguments Type Semantics     <code>operands</code> <code>N XlaOps</code> A sequence of N multi-dimensional arrays of types <code>T_0,..., T_{N-1}</code>, each representing the base area on which the window is placed.   <code>init_values</code> <code>N XlaOps</code> The N starting values for the reduction, one for each of the N operands. See Reduce for details.   <code>computation</code> <code>XlaComputation</code> Reduction function of type <code>T_0, ..., T_{N-1}, T_0, ..., T_{N-1} -&gt; Collate(T_0, ..., T_{N-1})</code>, to apply to elements in each window of all the input operands.   <code>window_dimensions</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for window dimension values   <code>window_strides</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for window stride values   <code>base_dilations</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for base dilation values   <code>window_dilations</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for window dilation values   <code>padding</code> <code>Padding</code> padding type for window (Padding::kSame, which pads so as to have the same output shape as input if the stride is 1, or Padding::kValid, which uses no padding and \"stops\" the window once it no longer fits)    <p>Where:</p> <ul> <li>N is required to be greater or equal to 1.</li> <li>All input arrays must have the same dimensions.</li> <li>If <code>N = 1</code>, <code>Collate(T)</code> is <code>T</code>.</li> <li>If <code>N &gt; 1</code>, <code>Collate(T_0, ..., T_{N-1})</code> is a tuple of <code>N</code> elements of type     <code>(T0,...T{N-1})</code>.</li> </ul> <p>Below code and figure shows an example of using <code>ReduceWindow</code>. Input is a matrix of size [4x6] and both window_dimensions and window_stride_dimensions are [2x3].</p> <pre><code>// Create a computation for the reduction (maximum).\nXlaComputation max;\n{\n  XlaBuilder builder(client_, \"max\");\n  auto y = builder.Parameter(0, ShapeUtil::MakeShape(F32, {}), \"y\");\n  auto x = builder.Parameter(1, ShapeUtil::MakeShape(F32, {}), \"x\");\n  builder.Max(y, x);\n  max = builder.Build().value();\n}\n\n// Create a ReduceWindow computation with the max reduction computation.\nXlaBuilder builder(client_, \"reduce_window_2x3\");\nauto shape = ShapeUtil::MakeShape(F32, {4, 6});\nauto input = builder.Parameter(0, shape, \"input\");\nbuilder.ReduceWindow(\n    input,\n    /*init_val=*/builder.ConstantLiteral(LiteralUtil::MinValue(F32)),\n    *max,\n    /*window_dimensions=*/{2, 3},\n    /*window_stride_dimensions=*/{2, 3},\n    Padding::kValid);\n</code></pre>  <p>Stride of 1 in a dimension specifies that the position of a window in the dimension is 1 element away from its adjacent window. In order to specify that no windows overlap with each other, window_stride_dimensions should be equal to window_dimensions. The figure below illustrates the use of two different stride values. Padding is applied to each dimension of the input and the calculations are the same as though the input came in with the dimensions it has after padding.</p>  <p>For a non-trivial padding example, consider computing reduce-window minimum (initial value is <code>MAX_FLOAT</code>) with dimension <code>3</code> and stride <code>2</code> over the input array <code>[10000, 1000, 100, 10, 1]</code>. Padding <code>kValid</code> computes minimums over two valid windows: <code>[10000, 1000, 100]</code> and <code>[100, 10, 1]</code>, resulting in the output <code>[100, 1]</code>. Padding <code>kSame</code> first pads the array so that the shape after the reduce-window would be the same as input for stride one by adding initial elements on both sides, getting <code>[MAX_VALUE, 10000, 1000, 100, 10, 1, MAX_VALUE]</code>. Running reduce-window over the padded array operates on three windows <code>[MAX_VALUE, 10000, 1000]</code>, <code>[1000, 100, 10]</code>, <code>[10, 1, MAX_VALUE]</code>, and yields <code>[1000, 10, 1]</code>.</p> <p>The evaluation order of the reduction function is arbitrary and may be non-deterministic. Therefore, the reduction function should not be overly sensitive to reassociation. See the discussion about associativity in the context of <code>Reduce</code> for more details.</p>"},{"location":"operation_semantics/#replicaid","title":"ReplicaId","text":"<p>See also <code>XlaBuilder::ReplicaId</code>.</p> <p>Returns the unique ID (U32 scalar) of the replica.</p> <p> <code>ReplicaId()</code> </p> <p>The unique ID of each replica is an unsigned integer in the interval <code>[0, N)</code>, where <code>N</code> is the number of replicas. Since all the replicas are running the same program, a <code>ReplicaId()</code> call in the program will return a different value on each replica.</p>"},{"location":"operation_semantics/#reshape","title":"Reshape","text":"<p>See also <code>XlaBuilder::Reshape</code> and the <code>Collapse</code> operation.</p> <p>Reshapes the dimensions of an array into a new configuration.</p> <p> <code>Reshape(operand, new_sizes)</code>   <code>Reshape(operand, dimensions, new_sizes)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T   <code>dimensions</code> <code>int64</code> vector order in which dimensions are collapsed   <code>new_sizes</code> <code>int64</code> vector vector of sizes of new dimensions    <p>Conceptually, reshape first flattens an array into a one-dimensional vector of data values, and then refines this vector into a new shape. The input arguments are an arbitrary array of type T, a compile-time-constant vector of dimension indices, and a compile-time-constant vector of dimension sizes for the result. The values in the <code>dimension</code> vector, if given, must be a permutation of all of T's dimensions; the default if not given is <code>{0, ..., rank - 1}</code>. The order of the dimensions in <code>dimensions</code> is from slowest-varying dimension (most major) to fastest-varying dimension (most minor) in the loop nest which collapses the input array into a single dimension. The <code>new_sizes</code> vector determines the size of the output array. The value at index 0 in <code>new_sizes</code> is the size of dimension 0, the value at index 1 is the size of dimension 1, and so on. The product of the <code>new_size</code> dimensions must equal the product of the operand's dimension sizes. When refining the collapsed array into the multidimensional array defined by <code>new_sizes</code>, the dimensions in <code>new_sizes</code> are ordered from slowest varying (most major) and to fastest varying (most minor).</p> <p>For example, let v be an array of 24 elements:</p> <pre><code>let v = f32[4x2x3] {{{10, 11, 12}, {15, 16, 17}},\n                    {{20, 21, 22}, {25, 26, 27}},\n                    {{30, 31, 32}, {35, 36, 37}},\n                    {{40, 41, 42}, {45, 46, 47}}};\n\nIn-order collapse:\nlet v012_24 = Reshape(v, {0,1,2}, {24});\nthen v012_24 == f32[24] {10, 11, 12, 15, 16, 17, 20, 21, 22, 25, 26, 27,\n                         30, 31, 32, 35, 36, 37, 40, 41, 42, 45, 46, 47};\n\nlet v012_83 = Reshape(v, {0,1,2}, {8,3});\nthen v012_83 == f32[8x3] {{10, 11, 12}, {15, 16, 17},\n                          {20, 21, 22}, {25, 26, 27},\n                          {30, 31, 32}, {35, 36, 37},\n                          {40, 41, 42}, {45, 46, 47}};\n\nOut-of-order collapse:\nlet v021_24 = Reshape(v, {1,2,0}, {24});\nthen v012_24 == f32[24]  {10, 20, 30, 40, 11, 21, 31, 41, 12, 22, 32, 42,\n                          15, 25, 35, 45, 16, 26, 36, 46, 17, 27, 37, 47};\n\nlet v021_83 = Reshape(v, {1,2,0}, {8,3});\nthen v021_83 == f32[8x3] {{10, 20, 30}, {40, 11, 21},\n                          {31, 41, 12}, {22, 32, 42},\n                          {15, 25, 35}, {45, 16, 26},\n                          {36, 46, 17}, {27, 37, 47}};\n\n\nlet v021_262 = Reshape(v, {1,2,0}, {2,6,2});\nthen v021_262 == f32[2x6x2] {{{10, 20}, {30, 40},\n                              {11, 21}, {31, 41},\n                              {12, 22}, {32, 42}},\n                             {{15, 25}, {35, 45},\n                              {16, 26}, {36, 46},\n                              {17, 27}, {37, 47}}};\n</code></pre> <p>As a special case, reshape can transform a single-element array to a scalar and vice versa. For example,</p> <pre><code>Reshape(f32[1x1] {{5}}, {0,1}, {}) == 5;\nReshape(5, {}, {1,1}) == f32[1x1] {{5}};\n</code></pre>"},{"location":"operation_semantics/#rev-reverse","title":"Rev (reverse)","text":"<p>See also <code>XlaBuilder::Rev</code>.</p> <p><code>Rev(operand, dimensions)</code></p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T   <code>dimensions</code> <code>ArraySlice&lt;int64&gt;</code> dimensions to reverse    <p>Reverses the order of elements in the <code>operand</code> array along the specified <code>dimensions</code>, generating an output array of the same shape. Each element of the operand array at a multidimensional index is stored into the output array at a transformed index. The multidimensional index is transformed by reversing the index in each dimension to be reversed (i.e., if a dimension of size N is one of the reversing dimensions, its index i is transformed into N - 1 - i).</p> <p>One use for the <code>Rev</code> operation is to reverse the convolution weight array along the two window dimensions during the gradient computation in neural networks.</p>"},{"location":"operation_semantics/#rngnormal","title":"RngNormal","text":"<p>See also <code>XlaBuilder::RngNormal</code>.</p> <p>Constructs an output of a given shape with random numbers generated following the \\(\\(N(\\mu, \\sigma)\\)\\) normal distribution. The parameters \\(\\(\\mu\\)\\) and \\(\\(\\sigma\\)\\), and output shape have to have a floating point elemental type. The parameters furthermore have to be scalar valued.</p> <p><code>RngNormal(mu, sigma, shape)</code></p>    Arguments Type Semantics     <code>mu</code> <code>XlaOp</code> Scalar of type T specifying mean of generated numbers   <code>sigma</code> <code>XlaOp</code> Scalar of type T specifying standard deviation of generated   <code>shape</code> <code>Shape</code> Output shape of type T"},{"location":"operation_semantics/#rnguniform","title":"RngUniform","text":"<p>See also <code>XlaBuilder::RngUniform</code>.</p> <p>Constructs an output of a given shape with random numbers generated following the uniform distribution over the interval \\(\\([a,b)\\)\\). The parameters and output element type have to be a boolean type, an integral type or a floating point types, and the types have to be consistent. The CPU and GPU backends currently only support F64, F32, F16, BF16, S64, U64, S32 and U32. Furthermore, the parameters need to be scalar valued. If \\(\\(b &lt;= a\\)\\) the result is implementation-defined.</p> <p><code>RngUniform(a, b, shape)</code></p>    Arguments Type Semantics     <code>a</code> <code>XlaOp</code> Scalar of type T specifying lower limit of interval   <code>b</code> <code>XlaOp</code> Scalar of type T specifying upper limit of interval   <code>shape</code> <code>Shape</code> Output shape of type T"},{"location":"operation_semantics/#rngbitgenerator","title":"RngBitGenerator","text":"<p>Generates an output with a given shape filled with uniform random bits using the specified algorithm (or backend default) and returns an updated state (with the same shape as initial state) and the generated random data.</p> <p>Initial state is the initial state of the current random number generation. It and the required shape and valid values are dependent on the algorithm used.</p> <p>The output is guaranteed to be a deterministic function of the initial state but it is not guaranteed to be deterministic between backends and different compiler versions.</p> <p><code>RngBitGenerator(algorithm, key, shape)</code></p>    Arguments Type Semantics     <code>algorithm</code> <code>RandomAlgorithm</code> PRNG algorithm to be used.   <code>initial_state</code> <code>XlaOp</code> Initial state for the PRNG algorithm.   <code>shape</code> <code>Shape</code> Output shape for generated data.    <p>Available values for <code>algorithm</code>:</p> <ul> <li> <p><code>rng_default</code>: Backend specific algorithm with backend specific shape     requirements.</p> </li> <li> <p><code>rng_three_fry</code>: ThreeFry counter-based PRNG algorithm. The <code>initial_state</code>     shape is <code>u64[2]</code> with arbitrary values.     Salmon et al. SC 2011. Parallel random numbers: as easy as 1, 2, 3.</p> </li> <li> <p><code>rng_philox</code>: Philox algorithm to generate random numbers in parallel. The     <code>initial_state</code> shape is <code>u64[3]</code> with arbitrary values.     Salmon et al. SC 2011. Parallel random numbers: as easy as 1, 2, 3.</p> </li> </ul>"},{"location":"operation_semantics/#scatter","title":"Scatter","text":"<p>The XLA scatter operation generates a sequence of results which are the values of the input array <code>operands</code>, with several slices (at indices specified by <code>scatter_indices</code>) updated with the sequence of values in <code>updates</code> using <code>update_computation</code>.</p> <p>See also <code>XlaBuilder::Scatter</code>.</p> <p> <code>scatter(operands..., scatter_indices, updates..., update_computation, index_vector_dim, update_window_dims, inserted_window_dims, scatter_dims_to_operand_dims)</code> </p>    Arguments Type Semantics     <code>operands</code> Sequence of N <code>XlaOp</code> N arrays of types <code>T_0, ..., T_N</code> to be scattered into.   <code>scatter_indices</code> <code>XlaOp</code> Array containing the starting indices of the slices that must be scattered to.   <code>updates</code> Sequence of N <code>XlaOp</code> N arrays of types <code>T_0, ..., T_N</code>. <code>updates[i]</code> contains the values that must be used for scattering <code>operands[i]</code>.   <code>update_computation</code> <code>XlaComputation</code> Computation to be used for combining the existing values in the input array and the updates during scatter. This computation should be of type <code>T_0, ..., T_N, T_0, ..., T_N -&gt; Collate(T_0, ..., T_N)</code>.   <code>index_vector_dim</code> <code>int64</code> The dimension in <code>scatter_indices</code> that contains the starting indices.   <code>update_window_dims</code> <code>ArraySlice&lt;int64&gt;</code> The set of dimensions in <code>updates</code> shape that are window dimensions.   <code>inserted_window_dims</code> <code>ArraySlice&lt;int64&gt;</code> The set of window dimensions that must be inserted into <code>updates</code> shape.   <code>scatter_dims_to_operand_dims</code> <code>ArraySlice&lt;int64&gt;</code> A dimensions map from the scatter indices to the operand index space. This array is interpreted as mapping <code>i</code> to <code>scatter_dims_to_operand_dims[i]</code> . It has to be one-to-one and total.   <code>indices_are_sorted</code> <code>bool</code> Whether the indices are guaranteed to be sorted by the caller.    <p>Where:</p> <ul> <li>N is required to be greater or equal to 1.</li> <li><code>operands</code>[<code>0</code>], ..., <code>operands</code>[<code>N-1</code>] must all have the same dimensions.</li> <li><code>updates</code>[<code>0</code>], ..., <code>updates</code>[<code>N-1</code>] must all have the same dimensions.</li> <li>If <code>N = 1</code>, <code>Collate(T)</code> is <code>T</code>.</li> <li>If <code>N &gt; 1</code>, <code>Collate(T_0, ..., T_N)</code> is a tuple of <code>N</code> elements of type <code>T</code>.</li> </ul> <p>If <code>index_vector_dim</code> is equal to <code>scatter_indices.rank</code> we implicitly consider <code>scatter_indices</code> to have a trailing <code>1</code> dimension.</p> <p>We define <code>update_scatter_dims</code> of type <code>ArraySlice&lt;int64&gt;</code> as the set of dimensions in <code>updates</code> shape that are not in <code>update_window_dims</code>, in ascending order.</p> <p>The arguments of scatter should follow these constraints:</p> <ul> <li> <p>Each <code>updates</code> array must be of rank <code>update_window_dims.size +     scatter_indices.rank - 1</code>.</p> </li> <li> <p>Bounds of dimension <code>i</code> in each <code>updates</code> array must conform to the     following:</p> <ul> <li>If <code>i</code> is present in <code>update_window_dims</code> (i.e. equal to     <code>update_window_dims</code>[<code>k</code>] for some <code>k</code>), then the bound of dimension <code>i</code>     in <code>updates</code> must not exceed the corresponding bound of <code>operand</code> after     accounting for the <code>inserted_window_dims</code> (i.e.     <code>adjusted_window_bounds</code>[<code>k</code>], where <code>adjusted_window_bounds</code> contains     the bounds of <code>operand</code> with the bounds at indices     <code>inserted_window_dims</code> removed).</li> <li>If <code>i</code> is present in <code>update_scatter_dims</code> (i.e. equal to     <code>update_scatter_dims</code>[<code>k</code>] for some <code>k</code>), then the bound of dimension     <code>i</code> in <code>updates</code> must be equal to the corresponding bound of     <code>scatter_indices</code>, skipping <code>index_vector_dim</code> (i.e.     <code>scatter_indices.shape.dims</code>[<code>k</code>], if <code>k</code> &lt; <code>index_vector_dim</code> and     <code>scatter_indices.shape.dims</code>[<code>k+1</code>] otherwise).</li> </ul> </li> <li> <p><code>update_window_dims</code> must be in ascending order, not have any repeating     dimension numbers, and be in the range <code>[0, updates.rank)</code>.</p> </li> <li> <p><code>inserted_window_dims</code> must be in ascending order, not have any repeating     dimension numbers, and be in the range <code>[0, operand.rank)</code>.</p> </li> <li> <p><code>operand.rank</code> must equal the sum of <code>update_window_dims.size</code> and     <code>inserted_window_dims.size</code>.</p> </li> <li> <p><code>scatter_dims_to_operand_dims.size</code> must be equal to     <code>scatter_indices.shape.dims</code>[<code>index_vector_dim</code>], and its values must be in     the range <code>[0, operand.rank)</code>.</p> </li> </ul> <p>For a given index <code>U</code> in each <code>updates</code> array, the corresponding index <code>I</code> in the corresponding <code>operands</code> array into which this update has to be applied is computed as follows:</p> <ol> <li>Let <code>G</code> = { <code>U</code>[<code>k</code>] for <code>k</code> in <code>update_scatter_dims</code> }. Use <code>G</code> to look up     an index vector <code>S</code> in the <code>scatter_indices</code> array such that <code>S</code>[<code>i</code>] =     <code>scatter_indices</code>[Combine(<code>G</code>, <code>i</code>)] where Combine(A, b) inserts b at     positions <code>index_vector_dim</code> into A.</li> <li>Create an index <code>S</code><code>in</code> into <code>operand</code> using <code>S</code> by scattering     <code>S</code> using the <code>scatter_dims_to_operand_dims</code> map. More formally:<ol> <li><code>S</code><code>in</code>[<code>scatter_dims_to_operand_dims</code>[<code>k</code>]] = <code>S</code>[<code>k</code>] if     <code>k</code> &lt; <code>scatter_dims_to_operand_dims.size</code>.</li> <li><code>S</code><code>in</code>[<code>_</code>] = <code>0</code> otherwise.</li> </ol> </li> <li>Create an index <code>W</code><code>in</code> into each <code>operands</code> array by scattering     the indices at <code>update_window_dims</code> in <code>U</code> according to     <code>inserted_window_dims</code>. More formally:<ol> <li><code>W</code><code>in</code>[<code>window_dims_to_operand_dims</code>(<code>k</code>)] = <code>U</code>[<code>k</code>] if <code>k</code>     is in <code>update_window_dims</code>, where <code>window_dims_to_operand_dims</code> is the     monotonic function with domain [<code>0</code>, <code>update_window_dims.size</code>) and     range [<code>0</code>, <code>operand.rank</code>) \\ <code>inserted_window_dims</code>. (For example, if     <code>update_window_dims.size</code> is <code>4</code>, <code>operand.rank</code> is <code>6</code>, and     <code>inserted_window_dims</code> is {<code>0</code>, <code>2</code>} then <code>window_dims_to_operand_dims</code>     is {<code>0</code>\u2192<code>1</code>, <code>1</code>\u2192<code>3</code>, <code>2</code>\u2192<code>4</code>, <code>3</code>\u2192<code>5</code>}).</li> <li><code>W</code><code>in</code>[<code>_</code>] = <code>0</code> otherwise.</li> </ol> </li> <li><code>I</code> is <code>W</code><code>in</code> + <code>S</code><code>in</code> where + is element-wise     addition.</li> </ol> <p>In summary, the scatter operation can be defined as follows.</p> <ul> <li>Initialize <code>output</code> with <code>operands</code>, i.e. for all indices <code>J</code>, for all     indices <code>O</code> in the <code>operands</code>[<code>J</code>] array: \\     <code>output</code>[<code>J</code>][<code>O</code>] = <code>operands</code>[<code>J</code>][<code>O</code>]</li> <li>For every index <code>U</code> in the <code>updates</code>[<code>J</code>] array and the corresponding index     <code>O</code> in the <code>operand</code>[<code>J</code>] array, if <code>O</code> is a valid index for <code>output</code>: \\     <code>(output</code>[<code>0</code>][<code>O</code>], ..., <code>output</code>[<code>N-1</code>][<code>O</code>])     =<code>update_computation</code>(<code>output</code>[<code>0</code>][<code>O</code>], ...,     ,<code>output</code>[<code>N-1</code>][<code>O</code>],<code>updates</code>[<code>0</code>][<code>U</code>], ...,<code>updates</code>[<code>N-1</code>][<code>U</code>])</li> </ul> <p>The order in which updates are applied is non-deterministic. So, when multiple indices in <code>updates</code> refer to the same index in <code>operands</code>, the corresponding value in <code>output</code> will be non-deterministic.</p> <p>Note that the first parameter that is passed into the <code>update_computation</code> will always be the current value from the <code>output</code> array and the second parameter will always be the value from the <code>updates</code> array. This is important specifically for cases when the <code>update_computation</code> is not commutative.</p> <p>If <code>indices_are_sorted</code> is set to true then XLA can assume that <code>start_indices</code> are sorted (in ascending <code>start_index_map</code> order) by the user. If they are not then the semantics is implementation defined.</p> <p>Informally, the scatter op can be viewed as an inverse of the gather op, i.e. the scatter op updates the elements in the input that are extracted by the corresponding gather op.</p> <p>For a detailed informal description and examples, refer to the \"Informal Description\" section under <code>Gather</code>.</p>"},{"location":"operation_semantics/#select","title":"Select","text":"<p>See also <code>XlaBuilder::Select</code>.</p> <p>Constructs an output array from elements of two input arrays, based on the values of a predicate array.</p> <p> <code>Select(pred, on_true, on_false)</code> </p>    Arguments Type Semantics     <code>pred</code> <code>XlaOp</code> array of type PRED   <code>on_true</code> <code>XlaOp</code> array of type T   <code>on_false</code> <code>XlaOp</code> array of type T    <p>The arrays <code>on_true</code> and <code>on_false</code> must have the same shape. This is also the shape of the output array. The array <code>pred</code> must have the same dimensionality as <code>on_true</code> and <code>on_false</code>, with the <code>PRED</code> element type.</p> <p>For each element <code>P</code> of <code>pred</code>, the corresponding element of the output array is taken from <code>on_true</code> if the value of <code>P</code> is <code>true</code>, and from <code>on_false</code> if the value of <code>P</code> is <code>false</code>. As a restricted form of broadcasting, <code>pred</code> can be a scalar of type <code>PRED</code>. In this case, the output array is taken wholly from <code>on_true</code> if <code>pred</code> is <code>true</code>, and from <code>on_false</code> if <code>pred</code> is <code>false</code>.</p> <p>Example with non-scalar <code>pred</code>:</p> <pre><code>let pred: PRED[4] = {true, false, false, true};\nlet v1: s32[4] = {1, 2, 3, 4};\nlet v2: s32[4] = {100, 200, 300, 400};\n==&gt;\nSelect(pred, v1, v2) = s32[4]{1, 200, 300, 4};\n</code></pre> <p>Example with scalar <code>pred</code>:</p> <pre><code>let pred: PRED = true;\nlet v1: s32[4] = {1, 2, 3, 4};\nlet v2: s32[4] = {100, 200, 300, 400};\n==&gt;\nSelect(pred, v1, v2) = s32[4]{1, 2, 3, 4};\n</code></pre> <p>Selections between tuples are supported. Tuples are considered to be scalar types for this purpose. If <code>on_true</code> and <code>on_false</code> are tuples (which must have the same shape!) then <code>pred</code> has to be a scalar of type <code>PRED</code>.</p>"},{"location":"operation_semantics/#selectandscatter","title":"SelectAndScatter","text":"<p>See also <code>XlaBuilder::SelectAndScatter</code>.</p> <p>This operation can be considered as a composite operation that first computes <code>ReduceWindow</code> on the <code>operand</code> array to select an element from each window, and then scatters the <code>source</code> array to the indices of the selected elements to construct an output array with the same shape as the operand array. The binary <code>select</code> function is used to select an element from each window by applying it across each window, and it is called with the property that the first parameter's index vector is lexicographically less than the second parameter's index vector. The <code>select</code> function returns <code>true</code> if the first parameter is selected and returns <code>false</code> if the second parameter is selected, and the function must hold transitivity (i.e., if <code>select(a, b)</code> and <code>select(b, c)</code> are <code>true</code>, then <code>select(a, c)</code> is also <code>true</code>) so that the selected element does not depend on the order of the elements traversed for a given window.</p> <p>The function <code>scatter</code> is applied at each selected index in the output array. It takes two scalar parameters:</p> <ol> <li>Current value at the selected index in the output array</li> <li>The scatter value from <code>source</code> that applies to the selected index</li> </ol> <p>It combines the two parameters and returns a scalar value that's used to update the value at the selected index in the output array. Initially, all indices of the output array are set to <code>init_value</code>.</p> <p>The output array has the same shape as the <code>operand</code> array and the <code>source</code> array must have the same shape as the result of applying a <code>ReduceWindow</code> operation on the <code>operand</code> array. <code>SelectAndScatter</code> can be used to backpropagate the gradient values for a pooling layer in a neural network.</p> <p><code>SelectAndScatter(operand, select, window_dimensions, window_strides, padding, source, init_value, scatter)</code></p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> array of type T over which the windows slide   <code>select</code> <code>XlaComputation</code> binary computation of type <code>T, T -&gt; PRED</code>, to apply to all elements in each window; returns <code>true</code> if the first parameter is selected and returns <code>false</code> if the second parameter is selected   <code>window_dimensions</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for window dimension values   <code>window_strides</code> <code>ArraySlice&lt;int64&gt;</code> array of integers for window stride values   <code>padding</code> <code>Padding</code> padding type for window (Padding::kSame or Padding::kValid)   <code>source</code> <code>XlaOp</code> array of type T with the values to scatter   <code>init_value</code> <code>XlaOp</code> scalar value of type T for the initial value of the output array   <code>scatter</code> <code>XlaComputation</code> binary computation of type <code>T, T -&gt; T</code>, to apply each scatter source element with its destination element    <p>The figure below shows examples of using <code>SelectAndScatter</code>, with the <code>select</code> function computing the maximal value among its parameters. Note that when the windows overlap, as in the figure (2) below, an index of the <code>operand</code> array may be selected multiple times by different windows. In the figure, the element of value 9 is selected by both of the top windows (blue and red) and the binary addition <code>scatter</code> function produces the output element of value 8 (2 + 6).</p>  <p>The evaluation order of the <code>scatter</code> function is arbitrary and may be non-deterministic. Therefore, the <code>scatter</code> function should not be overly sensitive to reassociation. See the discussion about associativity in the context of <code>Reduce</code> for more details.</p>"},{"location":"operation_semantics/#send","title":"Send","text":"<p>See also <code>XlaBuilder::Send</code>.</p> <p> <code>Send(operand, channel_handle)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> data to send (array of type T)   <code>channel_handle</code> <code>ChannelHandle</code> unique identifier for each send/recv pair    <p>Sends the given operand data to a <code>Recv</code> instruction in another computation that shares the same channel handle. Does not return any data.</p> <p>Similar to the <code>Recv</code> operation, the client API of <code>Send</code> operation represents synchronous communication, and is internally decomposed into 2 HLO instructions (<code>Send</code> and <code>SendDone</code>) to enable asynchronous data transfers. See also <code>HloInstruction::CreateSend</code> and <code>HloInstruction::CreateSendDone</code>.</p> <p><code>Send(HloInstruction operand, int64 channel_id)</code></p> <p>Initiates an asynchronous transfer of the operand to the resources allocated by the <code>Recv</code> instruction with the same channel id. Returns a context, which is used by a following <code>SendDone</code> instruction to wait for the completion of the data transfer. The context is a tuple of {operand (shape), request identifier (U32)} and it can only be used by a <code>SendDone</code> instruction.</p> <p> <code>SendDone(HloInstruction context)</code> </p> <p>Given a context created by a <code>Send</code> instruction, waits for the data transfer to complete.  The instruction does not return any data.</p> <p> Scheduling of channel instructions </p> <p>The execution order of the 4 instructions for each channel (<code>Recv</code>, <code>RecvDone</code>, <code>Send</code>, <code>SendDone</code>) is as below.</p>  <ul> <li><code>Recv</code> happens before <code>Send</code></li> <li><code>Send</code> happens before <code>RecvDone</code></li> <li><code>Recv</code> happens before <code>RecvDone</code></li> <li><code>Send</code> happens before <code>SendDone</code></li> </ul> <p>When the backend compilers generate a linear schedule for each computation that communicates via channel instructions, there must not be cycles across the computations. For example, below schedules lead to deadlocks.</p>"},{"location":"operation_semantics/#slice","title":"Slice","text":"<p>See also <code>XlaBuilder::Slice</code>.</p> <p>Slicing extracts a sub-array from the input array. The sub-array is of the same rank as the input and contains the values inside a bounding box within the input array where the dimensions and indices of the bounding box are given as arguments to the slice operation.</p> <p> <code>Slice(operand, start_indices, limit_indices, strides)</code> </p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> N dimensional array of type T   <code>start_indices</code> <code>ArraySlice&lt;int64&gt;</code> List of N integers containing the  starting indices of the slice for each dimension. Values must be greater than or equal to zero.   <code>limit_indices</code> <code>ArraySlice&lt;int64&gt;</code> List of N integers containing the ending indices (exclusive) for the slice for each dimension. Each value must be greater than or equal to the respective <code>start_indices</code> value for the dimension and less than or equal to the size of the dimension.   <code>strides</code> <code>ArraySlice&lt;int64&gt;</code> List of N integers that decides the input stride of the slice.  The slice picks every <code>strides[d]</code> element in dimension <code>d</code>.    <p>1-dimensional example:</p> <pre><code>let a = {0.0, 1.0, 2.0, 3.0, 4.0}\nSlice(a, {2}, {4}) produces:\n  {2.0, 3.0}\n</code></pre> <p>2-dimensional example:</p> <pre><code>let b =\n { {0.0,  1.0,  2.0},\n   {3.0,  4.0,  5.0},\n   {6.0,  7.0,  8.0},\n   {9.0, 10.0, 11.0} }\n\nSlice(b, {2, 1}, {4, 3}) produces:\n  { { 7.0,  8.0},\n    {10.0, 11.0} }\n</code></pre>"},{"location":"operation_semantics/#sort","title":"Sort","text":"<p>See also <code>XlaBuilder::Sort</code>.</p> <p><code>Sort(operands, comparator, dimension, is_stable)</code></p>    Arguments Type Semantics     <code>operands</code> <code>ArraySlice&lt;XlaOp&gt;</code> The operands to sort.   <code>comparator</code> <code>XlaComputation</code> The comparator computation to use.   <code>dimension</code> <code>int64</code> The dimension along which to sort.   <code>is_stable</code> <code>bool</code> Whether stable sorting should be used.    <p>If only one operand is provided:</p> <ul> <li> <p>If the operand is a rank-1 tensor (an array), the result is a sorted array.   If you want to sort the array into ascending order, the comparator should   perform a less-than comparison. Formally, after the array is sorted, it holds   for all index positions <code>i, j</code> with <code>i &lt; j</code> that either   <code>comparator(value[i], value[j]) = comparator(value[j], value[i]) = false</code> or   <code>comparator(value[i], value[j]) = true</code>.</p> </li> <li> <p>If the operand has higher rank, the operand is sorted along the provided   dimension. For example, for a rank-2 tensor (a matrix), a dimension value of   <code>0</code> will independently sort every column, and a dimension value of <code>1</code> will   independently sort each row. If no dimension number is provided, then the last   dimension is chosen by default. For the dimension which is sorted, the same   sorting order applies as in the rank-1 case.</p> </li> </ul> <p>If <code>n &gt; 1</code> operands are provided:</p> <ul> <li> <p>All <code>n</code> operands must be tensors with the same dimensions. The element types   of the tensors may be different.</p> </li> <li> <p>All operands are sorted together, not individually. Conceptually the operands   are treated as a tuple. When checking whether the elements of each operand at   index positions <code>i</code> and <code>j</code> need to be swapped, the comparator is called with   <code>2 * n</code> scalar parameters, where parameter <code>2 * k</code> corresponds to the value at   position <code>i</code> from the <code>k-th</code> operand, and parameter <code>2 * k + 1</code> corresponds to   the value at position <code>j</code> from the <code>k-th</code> operand. Usually, the comparator   would thus compare parameters <code>2 * k</code> and <code>2 * k + 1</code> with each other and   possibly use other parameter pairs as tie breakers.</p> </li> <li> <p>The result is a tuple that consists of the operands in sorted order (along   the provided dimension, as above). The <code>i-th</code> operand of the tuple corresponds   to the <code>i-th</code> operand of Sort.</p> </li> </ul> <p>For example, if there are three operands <code>operand0 = [3, 1]</code>, <code>operand1 = [42, 50]</code>, <code>operand2 = [-3.0, 1.1]</code>, and the comparator compares only the values of <code>operand0</code> with less-than, then the output of the sort is the tuple <code>([1, 3], [50, 42], [1.1, -3.0])</code>.</p> <p>If <code>is_stable</code> is set to true, the sort is guaranteed to be stable, that is, if there are elements which are considered to be equal by the comparator, the relative order of the equal values is preserved. Two elements <code>e1</code> and <code>e2</code> are equal if and only if <code>comparator(e1, e2) = comparator(e2, e1) = false</code>. By default, <code>is_stable</code> is set to false.</p>"},{"location":"operation_semantics/#transpose","title":"Transpose","text":"<p>See also the <code>tf.reshape</code> operation.</p> <p><code>Transpose(operand)</code></p>    Arguments Type Semantics     <code>operand</code> <code>XlaOp</code> The operand to transpose.   <code>permutation</code> <code>ArraySlice&lt;int64&gt;</code> How to permute the dimensions.    <p>Permutes the operand dimensions with the given permutation, so <code>\u2200 i . 0 \u2264 i &lt; rank \u21d2 input_dimensions[permutation[i]] = output_dimensions[i]</code>.</p> <p>This is the same as Reshape(operand, permutation,                             Permute(permutation, operand.shape.dimensions)).</p>"},{"location":"operation_semantics/#triangularsolve","title":"TriangularSolve","text":"<p>See also <code>XlaBuilder::TriangularSolve</code>.</p> <p>Solves systems of linear equations with lower or upper triangular coefficient matrices by forward- or back-substitution. Broadcasting along leading dimensions, this routine solves one of the matrix systems <code>op(a) * x = b</code>, or <code>x * op(a) = b</code>, for the variable <code>x</code>, given <code>a</code> and <code>b</code>, where <code>op(a)</code> is either <code>op(a) = a</code>, or <code>op(a) = Transpose(a)</code>, or <code>op(a) = Conj(Transpose(a))</code>.</p> <p> <code>TriangularSolve(a, b, left_side, lower, unit_diagonal, transpose_a)</code> </p>    Arguments Type Semantics     <code>a</code> <code>XlaOp</code> a rank &gt; 2 array of a complex or floating-point type with shape <code>[..., M, M]</code>.   <code>b</code> <code>XlaOp</code> a rank &gt; 2 array of the same type with shape <code>[..., M, K]</code> if <code>left_side</code> is true, <code>[..., K, M]</code> otherwise.   <code>left_side</code> <code>bool</code> indicates whether to solve a system of the form <code>op(a) * x = b</code> (<code>true</code>) or <code>x * op(a) = b</code> (<code>false</code>).   <code>lower</code> <code>bool</code> whether to use the upper or lower triangle of <code>a</code>.   <code>unit_diagonal</code> <code>bool</code> if <code>true</code>, the diagonal elements of <code>a</code> are assumed to be <code>1</code> and not accessed.   <code>transpose_a</code> <code>Transpose</code> whether to use <code>a</code> as is, transpose it or take its conjugate transpose.    <p>Input data is read only from the lower/upper triangle of <code>a</code>, depending on the value of <code>lower</code>. Values from the other triangle are ignored. Output data is returned in the same triangle; the values in the other triangle are implementation-defined and may be anything.</p> <p>If the rank of <code>a</code> and <code>b</code> are greater than 2, they are treated as batches of matrices, where all except the minor 2 dimensions are batch dimensions. <code>a</code> and <code>b</code> must have equal batch dimensions.</p>"},{"location":"operation_semantics/#tuple","title":"Tuple","text":"<p>See also <code>XlaBuilder::Tuple</code>.</p> <p>A tuple containing a variable number of data handles, each of which has its own shape.</p> <p>This is analogous to <code>std::tuple</code> in C++. Conceptually:</p> <pre><code>let v: f32[10] = f32[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nlet s: s32 = 5;\nlet t: (f32[10], s32) = tuple(v, s);\n</code></pre> <p>Tuples can be deconstructed (accessed) via the [<code>GetTupleElement</code>] (#gettupleelement) operation.</p>"},{"location":"operation_semantics/#while","title":"While","text":"<p>See also <code>XlaBuilder::While</code>.</p> <p> <code>While(condition, body, init)</code> </p>    Arguments Type Semantics     <code>condition</code> <code>XlaComputation</code> XlaComputation of type <code>T -&gt; PRED</code> which defines the termination condition of theloop.   <code>body</code> <code>XlaComputation</code> XlaComputation of type <code>T -&gt; T</code> which defines the body of the loop.   <code>init</code> <code>T</code> Initial value for the parameter of <code>condition</code> and <code>body</code>.    <p>Sequentially executes the <code>body</code> until the <code>condition</code> fails. This is similar to a typical while loop in many other languages except for the differences and restrictions listed below.</p> <ul> <li>A <code>While</code> node returns a value of type <code>T</code>, which is the result from the     last execution of the <code>body</code>.</li> <li>The shape of the type <code>T</code> is statically determined and must be the same     across all iterations.</li> </ul> <p>The T parameters of the computations are initialized with the <code>init</code> value in the first iteration and are automatically updated to the new result from <code>body</code> in each subsequent iteration.</p> <p>One main use case of the <code>While</code> node is to implement the repeated execution of training in neural networks. Simplified pseudocode is shown below with a graph that represents the computation. The code can be found in <code>while_test.cc</code>. The type <code>T</code> in this example is a <code>Tuple</code> consisting of an <code>int32</code> for the iteration count and a <code>vector[10]</code> for the accumulator. For 1000 iterations, the loop keeps adding a constant vector to the accumulator.</p> <pre><code>// Pseudocode for the computation.\ninit = {0, zero_vector[10]} // Tuple of int32 and float[10].\nresult = init;\nwhile (result(0) &lt; 1000) {\n  iteration = result(0) + 1;\n  new_vector = result(1) + constant_vector[10];\n  result = {iteration, new_vector};\n}\n</code></pre>"},{"location":"shapes/","title":"Shapes and layout","text":"<p>The XLA <code>Shape</code> proto (xla_data.proto) describes the rank, size, and data type of an N-dimensional array (array in short).</p>"},{"location":"shapes/#terminology-notation-and-conventions","title":"Terminology, notation, and conventions","text":"<ul> <li> <p>The rank of an array is equal to the number of dimensions. The true rank     of an array is the number of dimensions which have a size greater than 1.</p> </li> <li> <p>Dimensions are numbered from <code>0</code> up to <code>N-1</code> for an <code>N</code> dimensional array.     The dimension numbers are arbitrary labels for convenience. The order of     these dimension numbers does not imply a particular minor/major ordering in     the layout of the shape. The layout is determined by the <code>Layout</code> proto.</p> </li> <li> <p>By convention, dimensions are listed in increasing order of dimension     number. For example, for a 3-dimensional array of size <code>[A x B x C]</code>,     dimension 0 has size <code>A</code>, dimension 1 has size <code>B</code> and dimension 2 has size     <code>C</code>.</p> <p>Some utilities in XLA also support negative indexing, similarly to Python; dimension -1 is the last dimension (equivalent to <code>N-1</code> for an <code>N</code> dimensional array). For example, for the 3-dimensional array described above, dimension -1 has size <code>C</code>, dimension -2 has size <code>B</code> and so on.</p> </li> <li> <p>Two, three, and four dimensional arrays often have specific letters     associated with dimensions. For example, for a 2D array:</p> <ul> <li>dimension 0: <code>y</code></li> <li>dimension 1: <code>x</code></li> </ul> <p>For a 3D array:</p> <ul> <li>dimension 0: <code>z</code></li> <li>dimension 1: <code>y</code></li> <li>dimension 2: <code>x</code></li> </ul> <p>For a 4D array:</p> <ul> <li>dimension 0: <code>p</code></li> <li>dimension 1: <code>z</code></li> <li>dimension 2: <code>y</code></li> <li>dimension 3: <code>x</code></li> </ul> </li> <li> <p>Functions in the XLA API which take dimensions do so in increasing order of     dimension number. This matches the ordering used when passing dimensions as     an <code>initializer_list</code>; e.g.</p> <p><code>ShapeUtil::MakeShape(F32, {A, B, C, D})</code></p> <p>Will create a shape whose dimension size array consists of the sequence <code>[A, B, C, D]</code>.</p> </li> </ul>"},{"location":"shapes/#layout","title":"Layout","text":"<p>The <code>Layout</code> proto describes how an array is represented in memory. The <code>Layout</code> proto includes the following fields:</p> <pre><code>message Layout {\n  repeated int64 minor_to_major = 1;\n  repeated int64 padded_dimensions = 2;\n  optional PaddingValue padding_value = 3;\n}\n</code></pre>"},{"location":"shapes/#minor-to-major-dimension-ordering","title":"Minor-to-major dimension ordering","text":"<p>The only required field is <code>minor_to_major</code>. This field describes the minor-to-major ordering of the dimensions within a shape. Values in <code>minor_to_major</code> are an ordering of the dimensions of the array (<code>0</code> to <code>N-1</code> for an <code>N</code> dimensional array) with the first value being the most-minor dimension up to the last value which is the most-major dimension. The most-minor dimension is the dimension which changes most rapidly when stepping through the elements of the array laid out in linear memory.</p> <p>For example, consider the following 2D array of size <code>[2 x 3]</code>:</p> <pre><code>a b c\nd e f\n</code></pre> <p>Here dimension <code>0</code> is size 2, and dimension <code>1</code> is size 3. If the <code>minor_to_major</code> field in the layout is <code>[0, 1]</code> then dimension <code>0</code> is the most-minor dimension and dimension <code>1</code> is the most-major dimension. This corresponds to the following layout in linear memory:</p> <pre><code>a d b e c f\n</code></pre> <p>This minor-to-major dimension order of <code>0</code> up to <code>N-1</code> is akin to column-major (at rank 2). Assuming a monotonic ordering of dimensions, another name we may use to refer to this layout in the code is simply \"dim 0 is minor\".</p> <p>On the other hand, if the <code>minor_to_major</code> field in the layout is <code>[1, 0]</code> then the layout in linear memory is:</p> <pre><code>a b c d e f\n</code></pre> <p>A minor-to-major dimension order of <code>N-1</code> down to <code>0</code> for an <code>N</code> dimensional array is akin to row-major (at rank 2). Assuming a monotonic ordering of dimensions, another name we may use to refer to this layout in the code is simply \"dim 0 is major\".</p>"},{"location":"shapes/#default-minor-to-major-ordering","title":"Default minor-to-major ordering","text":"<p>The default layout for newly created Shapes is \"dimension order is major-to-minor\" (akin to row-major at rank 2).</p>"},{"location":"shapes/#padding","title":"Padding","text":"<p>Padding is defined in the optional <code>padded_dimensions</code> and <code>padding_value</code> fields. The field <code>padded_dimensions</code> describes the sizes (widths) to which each dimension is padded. If present, the number of elements in <code>padded_dimensions</code> must equal the rank of the shape.</p> <p>For example, given the <code>[2 x 3]</code> array defined above, if <code>padded_dimensions</code> is <code>[3, 5]</code> then dimension 0 is padded to a width of 3 and dimension 1 is padded to a width of 5. The layout in linear memory (assuming a padding value of 0 and column-major layout) is:</p> <pre><code>a d 0 b e 0 c f 0 0 0 0 0 0 0\n</code></pre> <p>This is equivalent to the layout of the following array with the same minor-to-major dimension order:</p> <pre><code>a b c 0 0\nd e f 0 0\n0 0 0 0 0\n</code></pre>"},{"location":"shapes/#indexing-into-arrays","title":"Indexing into arrays","text":"<p>The class <code>IndexUtil</code> in index_util.h provides utilities for converting between multidimensional indices and linear indices given a shape and layout. Multidimensional indices include a <code>int64</code> index for each dimension. Linear indices are a single <code>int64</code> value which indexes into the buffer holding the array. See <code>shape_util.h</code> and <code>layout_util.h</code> in the same directory for utilities that simplify creation and manipulation of shapes and layouts.</p>"},{"location":"tiled_layout/","title":"Tiled layout","text":"<p>Warning</p> <p>Tiled layout is pre-release and this describes how it's intended to work. Errors may be silently ignored.</p>  <p> Figure 1</p> <p>Figure 1 shows how an array F32[3,5] is laid out in memory with 2x2 tiling. A shape with this layout is written as F32[3,5]{1,0:T(2,2)}, where 1,0 relates to the physical order of dimensions (minor_to_major field in Layout) while (2,2) after the colon indicates tiling of the physical dimensions by a 2x2 tile.</p> <p>Intuitively tiles are laid out to cover the shape and then within each tile, elements are then laid out without tiling, as in the example above, where the right part of the example shows the layout in memory, including the white padding elements that are added in order to have complete 2x2 tiles even though the original array bounds are not even.</p> <p>The extra elements in the padding are not required to contain any particular value.</p>"},{"location":"tiled_layout/#linear-index-formulas-for-tiling-given-a-shape-and-a-tile","title":"Linear index formulas for tiling given a shape and a tile","text":"<p>Without tiling, an element e=(en, en-1, ... , e1) in an array with array bounds d=(dn, dn-1, ... , d1) (d1 is the most minor dimension) is laid out by major to minor order at position:</p> <p>\u00a0\u00a0 linear_index(e, d)  = linear_index((en, en-1, ... , e1), (dn, dn-1, ... , d1))  = endn-1...d1 + en-1dn-2...d1 + ... + e1</p> <p>For simplicity of notation in this document we assume a tile has the same number of dimensions as the array. In XLA's implementation of tiling, this is generalized to tilings with fewer dimensions by leaving the initial most-major dimensions unchanged and applying the tiling only to the most minor dimensions, so that the tiling that is specified mentions a suffix of the physical dimensions of the shape being tiled.</p> <p>When tiling of size (tn, tn-1, ... , t1) is used, an element in the array with indices (en, en-1, ... , e1) is mapped to this position in the final layout:</p> <p>\u00a0\u00a0 linear_index_with_tile(e, d, t)  = linear_index((\u230ae/t\u230b, e mod t), (\u2308d/t\u2309, t)) \u00a0 \u00a0 (arithmetic is elementwise, (a,b) is concatenation)  = linear_index((\u230aen/tn\u230b, ... , \u230ae1/t1\u230b, en mod tn, ... , e1 mod t1), (\u2308dn/tn\u2309, ... , \u2308d1/t1\u2309, tn, tn-1, ... , t1))  = linear_index((\u230aen/tn\u230b, ... , \u230ae1/t1\u230b), (\u2308dn/tn\u2309, ... , \u2308d1/t1\u2309))\u2219tntn-1...t1 + linear_index((en mod tn, ... , e1 mod t1), (tn, tn-1, ... , t1))</p> <p>The layout can be thought of as having two parts: (\u230aen/tn\u230b, ... , \u230ae1/t1\u230b), which corresponds to a tile index in an array of tiles of size (\u2308dn/tn\u2309, ... , \u2308d1/t1\u2309), and (en mod tn, ... , e1 mod t1), which corresponds to a within-tile index. The ceil function appears in \u2308di/ti\u2309 because if tiles overrun the bounds of the larger array, padding is inserted as in Figure 1. Both the tiles and elements within tiles are laid out recursively without tiling.</p> <p>For the example in Figure 1, element (2,3) has tile index (1,1), and within-tile index (0,1), for a combined coordinate vector of (1, 1, 0, 1). The tile indices have bounds (2, 3) and the tile itself is (2, 2) for a combined vector of (2, 3, 2, 2). The linear index with tile for the element with index (2, 3) in the logical shape is then</p> <p>\u00a0\u00a0 linear_index_with_tile((2,3), (3,5), (2,2))  = linear_index((1,1,0,1), (2,3,2,2))  = linear_index((1,1), (2,3)) \u2219 2 \u2219 2 + linear_index((0,1), (2,2))  = (1 \u2219 3 + 1) \u2219 2 \u2219 2 + (0 \u2219 2 + 1)  = 17.</p>"},{"location":"tiled_layout/#tiling-as-pad-reshape-transpose","title":"Tiling as pad-reshape-transpose","text":"<p>Tiling-based layout operates as follows:  Consider an array of dimensions (dn, dn-1, ... , d1) (d1 is the most minor dimension). When it\u2019s laid out with tiling of size (tn, tn-1, ... , t1) (t1 is the most minor dimension), that tiling can be described in terms of pad-reshape-transpose in the following way.</p> <ol> <li>The array is padded to (\u2308dn/tn\u2309\u2219tn, ... ,     \u2308d1/t1\u2309\u2219t1).</li> <li>Each dimension i is broken into (\u2308di/ti\u2309,     ti), i.e. the array is reshaped to      \u00a0 \u00a0 (\u2308dn/tn\u2309, tn, ... ,     \u2308d1/t1\u2309, t1).      There is no physical layout change in this reshape by itself, so this     reshape is a bitcast. If one is not explicitly thinking of a tiling, this     reshape could express any shape with the same number of elements as the     padded shape - the example here is of how to express a tile in this way.</li> <li>A transpose happens by moving tn, ... , t1 to the most     minor dimensions while keeping their relative order, so that the order of     dimensions from most major to most minor becomes      \u00a0 \u00a0 (\u2308dn/tn\u2309, ... ,     \u2308d1/t1\u2309, tn, ... , t1).</li> </ol> <p>The final shape has the prefix  \u00a0 \u00a0 (\u2308dn/tn\u2309, ... , \u2308d1/t1\u2309), which describes the number of tiles in each dimension. An element in the array (en, ... , e1) is mapped to this element in the final shape:  \u00a0 \u00a0 (\u230aen/tn\u230b, ... , \u230ae0/t0\u230b, en mod tn, ... , e1 mod t1). It is easy to see that the linear index of the element follows the formula above as expected.</p>"},{"location":"tiled_layout/#repeated-tiling","title":"Repeated tiling","text":"<p>XLA's tiling becomes even more flexible by applying it repeatedly.</p> <p> Figure 2</p> <p>Figure 2 shows how an array of size 4x8 is tiled by two levels of tiling (first 2x4 then 2x1). We represent this repeated tiling as (2,4)(2,1). Each color indicates a 2x4 tile and each red border box is a 2x1 tile. The numbers indicates the linear index in memory of that element in the tiled format. This format matches the format used for BF16 on TPU, except that the initial tile is bigger, namely the tiling is (8,128)(2,1), where the purpose of the second tiling by 2x1 is to collect together two 16 bit values to form one 32 bit value in a way that aligns with the architecture of a TPU.</p> <p>Note that a second or later tile can refer to both the minor within-tile dimensions, which just rearranges data within the tile, as in this example with (8,128)(2,1), but can also refer to the major cross-tile dimensions from the prior tiling.</p>"},{"location":"tiled_layout/#combining-dimensions-using-tiles","title":"Combining dimensions using tiles","text":"<p>XLA's tiling also supports combining dimensions. For example, it can combine dimensions in F32[2,7,8,11,10]{4,3,2,1,0} into F32[112,110]{1,0} first before tiling it with (2,3). The tile used is (\u2217,\u2217,2,\u2217,3). Here an asterisk in a tile implies taking that dimension and combining it with the next more minor dimension. Multiple adjacent dimensions can be subsumed together into one dimension. A subsumed dimension is represented by a tile value of -1 in that dimension of the tile, which is not otherwise valid in a tile as a dimension size.</p> <p>More precisely, if dimension i of the shape is eliminated via an asterisk in the tile, then before the prior definition of tiling is applied, that dimension is removed from both the shape being tiled and the tile vector, and what was dimension i-1 of the shape has its array bound increased from di-1 to didi-1. This step is repeated for each asterisk in the tile vector.</p>"}]}